# SintroNet - Gu√≠a de Implementaci√≥n
## Framework Minimalista para CQRS + SAGA + Event-Driven en .NET

> **Filosof√≠a:** "Minimal en configuraci√≥n. M√°ximo en potencia. La complejidad empresarial reducida a APIs declarativas."

---

## üìö √çndice

1. [Visi√≥n General](#visi√≥n-general)
2. [El Problema que Resolvemos](#el-problema-que-resolvemos)
3. [Soluci√≥n: API Declarativa](#soluci√≥n-api-declarativa)
4. [Similitudes con SyntroJS](#similitudes-con-syntrojs)
5. [Ventajas Exclusivas de .NET](#ventajas-exclusivas-de-net)
6. [Swagger y Documentaci√≥n Autom√°tica](#swagger-y-documentaci√≥n-autom√°tica)
7. [Observabilidad y Logging](#observabilidad-y-logging)
8. [Arquitectura Interna](#arquitectura-interna)
9. [Stack Tecnol√≥gico](#stack-tecnol√≥gico)
10. [Implementaci√≥n Detallada](#implementaci√≥n-detallada)
11. [Consideraciones para Agentes de IA](#consideraciones-para-agentes-de-ia)

---

## üéØ Visi√≥n General

**SintroNet** es una librer√≠a de .NET que abstrae toda la complejidad de arquitectura empresarial (CQRS, SAGAs, Event-Driven, Proyecciones) detr√°s de una API declarativa extremadamente simple, inspirada en **SyntroJS** pero aprovechando las ventajas √∫nicas de .NET.

### Principios Fundamentales

1. **Configuraci√≥n Declarativa**: El usuario define QU√â necesita, la librer√≠a maneja C√ìMO
2. **Abstracci√≥n Total**: CQRS, SAGAs, eventos, proyecciones son impl√≠citos
3. **Zero Boilerplate**: No hay CommandHandlers, QueryHandlers, EventHandlers manuales
4. **Auto-Orchestration**: SAGAs se generan autom√°ticamente desde la configuraci√≥n
5. **Type-Safe**: Todo fuertemente tipado con compilaci√≥n est√°tica
6. **Observability First**: Logging, m√©tricas y tracing con m√≠nima configuraci√≥n
7. **Swagger Integrado**: OpenAPI y documentaci√≥n interactiva autom√°tica
8. **Performance Nativo**: Aprovecha .NET para m√°ximo rendimiento

---

## ‚ùå El Problema que Resolvemos

### C√≥digo Tradicional (Sin Framework)

```csharp
// ‚ùå El usuario necesita escribir MILES de l√≠neas:

// 1. Domain Aggregate
public class Order : AggregateRoot { /* 100+ l√≠neas */ }

// 2. Command
public class CreateOrderCommand : IRequest<OrderDto> { }

// 3. Command Handler
public class CreateOrderCommandHandler : IRequestHandler<CreateOrderCommand, OrderDto> 
{ 
    /* 50+ l√≠neas de l√≥gica boilerplate */
}

// 4. Query
public class GetOrderByIdQuery : IRequest<OrderDto> { }

// 5. Query Handler
public class GetOrderByIdQueryHandler : IRequestHandler<GetOrderByIdQuery, OrderDto>
{
    /* 50+ l√≠neas de l√≥gica boilerplate */
}

// 6. Event Handlers
public class OrderPlacedEventHandler : IEventHandler<OrderPlacedEvent> { }
public class OrderProjectionHandler : IConsumer<OrderPlacedEvent> { }

// 7. SAGA
public class OrderProcessingSaga : ISaga { /* 200+ l√≠neas */ }

// 8. DTOs, Mappings, Configuraciones...
// TOTAL: 2000+ l√≠neas para una entidad simple
```

---

## ‚úÖ Soluci√≥n: API Declarativa

### C√≥digo con SyntroJS for .NET

```csharp
// ‚úÖ El usuario escribe SOLO 20 l√≠neas:

using SyntroJS;

var app = SyntroApp.Create();

// Definir entidad Order con configuraci√≥n declarativa
app.Entity<Order>()
    .Write(model => model
        .Aggregate<OrderAggregate>()  // La librer√≠a crea el aggregate
        .AutoCreateEndpoint()          // POST /api/orders
        .AutoUpdateEndpoint()          // PUT /api/orders/{id}
        .AutoDeleteEndpoint()          // DELETE /api/orders/{id}
        .OnCreated("OrderPlaced")      // Emite evento autom√°ticamente
    )
    .Read(model => model
        .AutoGetByIdEndpoint()         // GET /api/orders/{id}
        .AutoListEndpoint()            // GET /api/orders
        .AutoSearchEndpoint()          // GET /api/orders?search=...
        .Projection<OrderView>()       // Proyecci√≥n autom√°tica
        .Cache(duration: 5.Minutes())  // Cache autom√°tico
    )
    .Saga("OrderProcessing", saga => saga
        .Step<OrderPlacedEvent>(async (ctx, next) =>
        {
            // Reservar inventario
            await ReserveInventory(ctx.Order.Items);
            await ctx.Publish("InventoryReserved");
        })
        .Step<InventoryReservedEvent>(async (ctx, next) =>
        {
            // Procesar pago
            await ProcessPayment(ctx.Order.Total);
            await ctx.Publish("PaymentProcessed");
        })
        .Step<PaymentProcessedEvent>(async (ctx, next) =>
        {
            // Completar orden
            await CompleteOrder(ctx.OrderId);
        })
        .Compensate(async (ctx) =>
        {
            // Rollback autom√°tico si falla
            await ReleaseInventory(ctx.Order.Items);
        })
    );

app.Run();
```

**Lo que la librer√≠a genera autom√°ticamente:**
- ‚úÖ Commands y Command Handlers
- ‚úÖ Queries y Query Handlers
- ‚úÖ Event Handlers
- ‚úÖ Projections
- ‚úÖ SAGA completa con compensaci√≥n
- ‚úÖ Endpoints REST
- ‚úÖ Validaci√≥n autom√°tica
- ‚úÖ Mapeos DTO ‚Üî Aggregate
- ‚úÖ Migraciones EF Core
- ‚úÖ Queries optimizadas con Dapper
- ‚úÖ OpenAPI/Swagger autom√°tico
- ‚úÖ Logging estructurado
- ‚úÖ M√©tricas y trazabilidad

---

## üîÑ Similitudes con SyntroJS

### API Fluent Similar

**SintroNet** toma inspiraci√≥n directa de **SyntroJS**:

#### SyntroJS (TypeScript/Node.js)
```typescript
app.post('/orders', {
  body: OrderSchema,
  status: 201,
  dependencies: { db: inject(getDatabase) },
  handler: ({ body, dependencies }) => 
    dependencies.db.orders.create(body)
});
```

#### SintroNet (C#)
```csharp
app.Entity<Order>()
    .Write(model => model
        .AutoCreateEndpoint()  // POST /api/orders
        .UseAggregate<OrderAggregate>()
        .Dependencies(db => db.Use<Database>())
    );
```

### Caracter√≠sticas Compartidas

| Caracter√≠stica | SyntroJS | SintroNet |
|----------------|----------|-----------|
| **API Declarativa** | ‚úÖ | ‚úÖ |
| **Zero Boilerplate** | ‚úÖ | ‚úÖ |
| **Dependency Injection** | ‚úÖ | ‚úÖ |
| **Validaci√≥n Autom√°tica** | ‚úÖ | ‚úÖ |
| **OpenAPI/Swagger** | ‚úÖ | ‚úÖ |
| **Type-Safe** | ‚úÖ TypeScript | ‚úÖ C# Strong Typing |
| **Event-Driven** | ‚úÖ | ‚úÖ |
| **CQRS** | Manual | ‚úÖ Auto-generado |
| **SAGAs** | Manual | ‚úÖ Auto-orquestadas |

---

## üöÄ Ventajas Exclusivas de .NET

### 1. Compilaci√≥n Est√°tica
```csharp
// ‚ùå Error en COMPILACI√ìN, no en runtime
app.Entity<Order>()
    .Write(model => model
        .AutoCreateEndpoint()
        .InvalidMethod()  // ‚Üê Errores detectados en dev
    );
```

### 2. Performance Nativo
```csharp
// .NET compilado a m√°quina nativa
// - 10x m√°s r√°pido que Node.js para CPU-bound
// - Menor consumo de memoria
// - Mejor latencia
```

### 3. Tooling Ecosystem
```csharp
// JetBrains Rider / Visual Studio
// - IntelliSense perfecto
// - Refactoring autom√°tico
// - Debug visual
// - Profiling integrado
```

### 4. Generics y Type System Avanzado
```csharp
// Type inference extremo
app.Entity<Order>()
    .Read(model => model
        .AutoGetByIdEndpoint<Guid>()  // Type inferido
        .AutoListEndpoint()            // PagedResponse<T> inferido
        .AutoSearchEndpoint(query => query
            .Where(o => o.Total > 100)  // Expression trees compiladas
        )
    );
```

### 5. Null Safety
```csharp
// C# 11 nullable reference types
public record OrderDto(
    Guid Id,
    string CustomerName,  // Non-nullable
    string? Notes        // Nullable expl√≠cito
);
```

### 6. Pattern Matching Avanzado
```csharp
app.Entity<Order>()
    .Saga("OrderProcessing", saga => saga
        .Step<OrderPlacedEvent>(async ctx => 
            ctx.Order.Status switch
            {
                OrderStatus.Draft => await ProcessDraft(ctx),
                OrderStatus.Pending => await ProcessPending(ctx),
                _ => throw new InvalidOperationException()
            }
        )
    );
```

---

## üìã Swagger y Documentaci√≥n Autom√°tica

### Auto-Generaci√≥n de OpenAPI

**SintroNet** genera autom√°ticamente OpenAPI 3.0 desde la configuraci√≥n declarativa:

```csharp
var app = SyntroApp.Create()
    .EnableSwagger(config => config
        .Title("E-Commerce API")
        .Description("API for managing orders and products")
        .Version("v1")
        .AddServer("https://api.example.com")
        .AddServer("https://staging.example.com", "Staging")
    );

app.Entity<Order>()
    .Write(model => model
        .AutoCreateEndpoint()
        .Summary("Create a new order")
        .Description("Allows customers to create orders")
        .ProducesResponse<OrderDto>(201, "Order created successfully")
        .ProducesResponse(400, "Validation error")
    )
    .Read(model => model
        .AutoGetByIdEndpoint()
        .Summary("Get order by ID")
        .ProducesResponse<OrderDto>(200, "Order found")
        .ProducesResponse(404, "Order not found")
    );
```

### UI Interactiva

```
GET /swagger        ‚Üí Swagger UI (interactive)
GET /swagger/v1/swagger.json  ‚Üí OpenAPI spec
GET /redoc         ‚Üí ReDoc (alternative UI)
```

### Documentaci√≥n Autom√°tica

```csharp
public record OrderDto(
    /// <summary>Unique order identifier</summary>
    /// <example>123e4567-e89b-12d3-a456-426614174000</example>
    Guid Id,
    
    /// <summary>Customer ID who placed the order</summary>
    Guid CustomerId,
    
    /// <summary>Total amount including tax</summary>
    /// <example>99.99</example>
    decimal Total,
    
    /// <summary>Order status</summary>
    /// <example>Pending</example>
    OrderStatus Status
);
```

---

## üìä Observabilidad y Logging

### Logging Estructurado Autom√°tico

```csharp
var app = SyntroApp.Create()
    .UseLogger(config => config
        .AddConsole()                    // Console logs
        .AddSeq("http://localhost:5341")  // Seq aggregation
        .AddApplicationInsights()         // Azure telemetry
        .SetMinimumLevel(LogLevel.Information)
    );

// Los logs se generan autom√°ticamente:
// [INFO] Order created: { OrderId: "abc", CustomerId: "xyz", Total: 99.99 }
// [INFO] Command processed: CreateOrderCommand in 45ms
// [ERROR] Validation failed: { Field: "CustomerId", Error: "Required" }
```

### Logging a Demanda

```csharp
app.Entity<Order>()
    .Write(model => model
        .AutoCreateEndpoint()
        .LogRequest()     // Log incoming requests
        .LogResponse()    // Log outgoing responses
        .LogPerformance() // Log execution time
        .LogErrors()      // Log exceptions
    );
```

### M√©tricas Autom√°ticas

```csharp
var app = SyntroApp.Create()
    .UseMetrics(config => config
        .Counter("orders_created_total")
        .Histogram("order_processing_duration_ms")
        .Gauge("active_orders_count")
    );

// M√©tricas expuestas autom√°ticamente en /metrics (Prometheus format)
```

### Distributed Tracing

```csharp
var app = SyntroApp.Create()
    .UseTracing(config => config
        .AddOpenTelemetry()  // OpenTelemetry est√°ndar
        .AddJaeger()         // Jaeger integration
        .AddZipkin()         // Zipkin integration
    );

// Traces autom√°ticos para:
// - Request lifecycle
// - Database queries
// - External API calls
// - SAGA steps
// - Event publishing
```

### Observabilidad Completa

```csharp
var app = SyntroApp.Create()
    .EnableObservability(config => config
        .RequestId()              // Correlation IDs
        .UserAgent()              // Client info
        .Duration()               // Request duration
        .StatusCodes()            // Response codes
        .ExceptionDetails()       // Stack traces
        .CustomTags(tags => tags  // Custom metadata
            .Add("environment", "production")
            .Add("version", "1.0.0")
        )
    );
```

---

## üèóÔ∏è Arquitectura Interna

La librer√≠a internamente organiza todo como arquitectura CQRS/SAGA:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   SyntroApp (User Code)                     ‚îÇ
‚îÇ  app.Entity<Order>().Write().Read().Saga()                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              SyntroJS.Core (Library Core)                   ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ
‚îÇ  ‚îÇ  EntityRegistry: Convierte configuraci√≥n       ‚îÇ        ‚îÇ
‚îÇ  ‚îÇ  declarativa en arquitectura CQRS              ‚îÇ        ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ
‚îÇ  ‚îÇ  CommandGenerator: Genera Commands + Handlers  ‚îÇ        ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ
‚îÇ  ‚îÇ  QueryGenerator: Genera Queries + Handlers     ‚îÇ        ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ
‚îÇ  ‚îÇ  ProjectionGenerator: Genera proyecciones      ‚îÇ        ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ
‚îÇ  ‚îÇ  SagaGenerator: Genera SAGAs con compensaci√≥n  ‚îÇ        ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ          SyntroJS.Infrastructure (Generated Code)           ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îÇ
‚îÇ  ‚îÇ  Commands/       ‚îÇ  ‚îÇ  Queries/        ‚îÇ                ‚îÇ
‚îÇ  ‚îÇ  Handlers        ‚îÇ  ‚îÇ  Handlers        ‚îÇ                ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îÇ
‚îÇ  ‚îÇ  Events/         ‚îÇ  ‚îÇ  Sagas/          ‚îÇ                ‚îÇ
‚îÇ  ‚îÇ  Projections     ‚îÇ  ‚îÇ  Orchestration   ‚îÇ                ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              MassTransit + MediatR + EF Core                ‚îÇ
‚îÇ              (Orquestaci√≥n, Event Bus, Persistence)         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üîê Idempotencia Autom√°tica (Inbox Pattern)

### El Problema de Mensajes Duplicados

En sistemas distribuidos basados en eventos, los message brokers garantizan entrega "at-least-once" (al menos una vez). Esto significa que el mismo mensaje puede entregarse m√∫ltiples veces.

**Consecuencias sin Idempotencia:**
```csharp
// ‚ùå Sin idempotencia: Procesar pago DOS veces
PaymentProcessedEvent (ID: "abc-123") ‚Üí Procesar $100
PaymentProcessedEvent (ID: "abc-123") ‚Üí Procesar $100 OTRA VEZ ‚ùå

// Cliente cobrado $200 en lugar de $100
```

### Soluci√≥n: Inbox Pattern Autom√°tico

**SintroNet** implementa autom√°ticamente el **Inbox Pattern**, garantizando que cada mensaje se procese exactamente una vez:

```csharp
app.Entity<Order>()
    .Write(model => model
        .AutoCreateEndpoint()
        .WithIdempotency()  // ‚Üê Una sola l√≠nea habilita idempotencia
    );

// Tambi√©n funciona en SAGAs
app.Saga("OrderProcessing", saga => saga
    .Step<PaymentProcessedEvent>(async (ctx, next) => 
    {
        await ProcessPayment(ctx.Amount);
    })
    .WithIdempotency()  // ‚Üê Protege contra duplicados
);
```

### ¬øC√≥mo Funciona Internamente?

La librer√≠a mantiene una tabla `inbox_messages`:

```sql
CREATE TABLE inbox_messages (
    id UUID PRIMARY KEY,        -- Message ID √∫nico
    handler_name VARCHAR(255),  -- Handler que procesa el mensaje
    processed_at TIMESTAMP,     -- Cu√°ndo se proces√≥
    payload TEXT                -- Serializaci√≥n del mensaje
);
```

**Flujo Autom√°tico:**
1. Mensaje llega con ID `"abc-123"`
2. Librer√≠a verifica: `SELECT * FROM inbox_messages WHERE id = 'abc-123'`
3. Si existe ‚Üí Ignora mensaje (ya procesado)
4. Si no existe ‚Üí Procesa mensaje y guarda en `inbox_messages`

### Configuraci√≥n Avanzada

```csharp
app.UseInbox(config => config
    .Provider<SqlServerInbox>()  // PostgreSQL, MySQL, etc.
    .RetentionDays(90)            // Limpiar mensajes antiguos
    .BatchSize(100)                // Procesar en lotes
);
```

**Beneficios:**
- ‚úÖ Garant√≠a de procesamiento exactamente-una-vez
- ‚úÖ Zero configuraci√≥n por default
- ‚úÖ Transparente para el desarrollador
- ‚úÖ Soporte multi-provider (SQL, MongoDB, etc.)

---

## üì¶ Event Sourcing (Opcional)

### ¬øQu√© es Event Sourcing?

**Event Sourcing** es una estrategia de persistencia donde en lugar de guardar el **estado actual** del agregado, guardamos la **secuencia inmutable de eventos** que ocurrieron.

### Comparaci√≥n: Estado vs Eventos

| Aspecto | Estado Tradicional | Event Sourcing |
|---------|-------------------|----------------|
| **Persistencia** | Tabla `Orders` con estado actual | Tabla `events` con historia |
| **Queries** | ‚úÖ Directo (SELECT * FROM Orders) | ‚ùå Requiere replay eventos |
| **Auditor√≠a** | ‚ùå Limitada (solo estado actual) | ‚úÖ Historial completo |
| **Time Travel** | ‚ùå Imposible | ‚úÖ Ver estado en cualquier momento |
| **Nuevas Proyecciones** | ‚ùå Requiere migraci√≥n | ‚úÖ Replay eventos hist√≥ricos |
| **Debugging** | ‚ùå Solo estado actual | ‚úÖ Ver exactamente qu√© pas√≥ |

### API Declarativa con Event Sourcing

```csharp
app.Entity<Order>()
    .Write(model => model
        .UseEventSourcing()        // ‚Üê Habilita Event Sourcing
        .AutoCreateEndpoint()
        .SnapshotEvery(100)        // Performance: snapshot cada 100 eventos
    );
```

### Flujo Interno

```csharp
// 1. Comando llega: CreateOrderCommand
var command = new CreateOrderCommand { CustomerId = "abc", Items = [...] };

// 2. Librer√≠a reconstruye agregado (si existe)
var order = await eventStore.GetAggregate<Order>(orderId);
// Reproduce eventos: OrderCreated ‚Üí OrderItemAdded ‚Üí OrderPaid

// 3. Ejecuta l√≥gica de negocio
order.AddItem(newItem);

// 4. Guarda NUEVO evento (no actualiza estado)
await eventStore.AppendEvent(new OrderItemAddedEvent { ... });
```

### Configuraci√≥n

```csharp
app.UseEventStore(config => config
    .Provider<PostgresEventStore>()  // o SQL Server, MongoDB
    .EnableSnapshots()                // Performance
    .RetentionPolicy(years: 7)        // Retenci√≥n hist√≥rica
);
```

**Casos de Uso:**
- ‚úÖ Sistemas financieros (auditor√≠a completa requerida)
- ‚úÖ Sistemas de compliance (historial inmutable)
- ‚úÖ Analytics y machine learning (todos los eventos hist√≥ricos)
- ‚úÖ Domain Events complejos (workflow rastreado)

---

## üîÑ Evoluci√≥n de Esquemas de Eventos

### El Problema del Versionado

Los eventos evolucionan con el tiempo:
```csharp
// Versi√≥n 1 (t0)
public record OrderPlacedEvent(
    Guid OrderId,
    Guid CustomerId,
    decimal Total
);

// Versi√≥n 2 (t1) - Campo nuevo a√±adido
public record OrderPlacedEvent(
    Guid OrderId,
    Guid CustomerId,
    decimal Total,
    string? DiscountCode  // ‚Üê Nuevo campo
);
```

**Problema:** Consumidores antiguos procesando eventos nuevos rompen.

### Estrategias

#### 1. Tolerant Reader (Recomendado)

Dise√±a consumidores que ignoren campos desconocidos:

```csharp
public class OrderProjection : IEventHandler<OrderPlacedEvent>
{
    public async Task Handle(OrderPlacedEvent @event)
    {
        // ‚úÖ IGNORA campos desconocidos
        // @event.DiscountCode ser√° null para eventos v1, OK!
        
        await UpdateProjection(@event.OrderId, @event.CustomerId, @event.Total);
    }
}
```

#### 2. Campos Opcionales Siempre

```csharp
// ‚úÖ BIEN: Nuevos campos siempre opcionales
public record OrderPlacedEvent(
    Guid OrderId,
    string? DiscountCode = null,  // ‚Üê Nullable con default
    Guid? CampaignId = null
);
```

#### 3. Upcasting Autom√°tico

**SintroNet** puede convertir eventos v1 a v2 autom√°ticamente:

```csharp
app.Events(config => config
    .Upcast<OrderPlacedEventV1, OrderPlacedEventV2>(v1 => new OrderPlacedEventV2
    {
        OrderId = v1.OrderId,
        CustomerId = v1.CustomerId,
        Total = v1.Total,
        DiscountCode = null  // ‚Üê Valor por defecto
    })
);
```

**Flujo:**
1. Evento v1 deserializado desde almacenamiento
2. Upcaster convierte a v2 en memoria
3. Handler recibe evento v2
4. Transparente para consumidor

#### 4. Versionado en Nombre (Breaking Changes)

Para cambios incompatibles:

```csharp
// Eventos completamente diferentes
public record OrderPlacedV2Event(...) { }
public record OrderPlacedV3Event(...) { }

// Consumidores espec√≠ficos
app.Consume<OrderPlacedV2Event>(...)
app.Consume<OrderPlacedV3Event>(...)
```

### Mejores Pr√°cticas

1. **Siempre** a√±ade campos opcionales
2. **Nunca** elimines campos existentes
3. **Usa** Tolerant Reader por defecto
4. **Documenta** cambios de schema
5. **Versiona** para breaking changes

---

## üéº SAGAs: Orquestaci√≥n vs Coreograf√≠a

### Orquestaci√≥n (Centralizada)

Una clase central orquesta el flujo completo:

```csharp
app.Saga("OrderProcessing", saga => saga
    .Orchestration()  // ‚Üê Modo orquestado
    .Step<OrderPlacedEvent>(async (ctx, next) => 
    {
        await ReserveInventory(ctx);
        await ctx.Publish("InventoryReserved");
    })
    .Step<InventoryReservedEvent>(async (ctx, next) => 
    {
        await ProcessPayment(ctx);
        await ctx.Publish("PaymentProcessed");
    })
);
```

**Caracter√≠sticas:**
- ‚úÖ Flujo centralizado y f√°cil de entender
- ‚úÖ Monitoreo en un solo lugar
- ‚úÖ L√≥gica de compensaci√≥n compleja
- ‚ùå Acoplamiento entre servicios

**Ideal para:** Workflows complejos (3+ pasos), transacciones cr√≠ticas

### Coreograf√≠a (Descentralizada)

Cada servicio reacciona a eventos publicados:

```csharp
// Order Service
app.Consume<PaymentProcessedEvent>(async (@event) => 
{
    await MarkOrderAsCompleted(@event.OrderId);
});

// Inventory Service
app.Consume<OrderPlacedEvent>(async (@event) => 
{
    await ReserveInventory(@event.Items);
    await ctx.Publish("InventoryReserved");
});

// Payment Service
app.Consume<InventoryReservedEvent>(async (@event) => 
{
    await ChargeCustomer(@event.OrderId);
    await ctx.Publish("PaymentProcessed");
});
```

**Caracter√≠sticas:**
- ‚úÖ Desacoplamiento total
- ‚úÖ Autonom√≠a de servicios
- ‚úÖ Escalabilidad independiente
- ‚ùå Flujo distribuido (m√°s dif√≠cil debuggear)

**Ideal para:** Workflows simples (2-3 pasos), microservicios independientes

### Decisi√≥n

| Criterio | Orquestaci√≥n | Coreograf√≠a |
|----------|--------------|-------------|
| **Complejidad** | Alta | Baja |
| **Pasos** | 3+ | 1-3 |
| **Compensaci√≥n** | Compleja | Simple |
| **Desacoplamiento** | Medio | Alto |
| **Debugging** | F√°cil | Dif√≠cil |
| **Monitoreo** | Centralizado | Distribuido |

**Recomendaci√≥n:** Orquestaci√≥n para workflows cr√≠ticos, Coreograf√≠a para notificaciones simples.

---

## üõ†Ô∏è Stack Tecnol√≥gico

### Core Framework
```xml
<PackageReference Include="Microsoft.NET" Version="8.0" />
<PackageReference Include="MediatR" Version="12.2.0" />
<PackageReference Include="FluentValidation" Version="11.9.0" />
<PackageReference Include="AutoMapper" Version="12.0.1" />
```

### Persistence
```xml
<!-- Write Database -->
<PackageReference Include="Microsoft.EntityFrameworkCore" Version="8.0.0" />
<PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" Version="8.0.0" />
<PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="8.0.0" />

<!-- Read Database (Dapper) -->
<PackageReference Include="Dapper" Version="2.1.24" />
<PackageReference Include="System.Data.SqlClient" Version="4.8.6" />

<!-- Caching -->
<PackageReference Include="StackExchange.Redis" Version="2.7.10" />
```

### Messaging
```xml
<PackageReference Include="MassTransit" Version="8.1.3" />
<PackageReference Include="MassTransit.RabbitMQ" Version="8.1.3" />
<!-- O alternativamente: -->
<PackageReference Include="MassTransit.Azure.ServiceBus.Core" Version="8.1.3" />
```

### API
```xml
<PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="8.0.0" />
<PackageReference Include="Swashbuckle.AspNetCore" Version="6.5.0" />
<PackageReference Include="Serilog.AspNetCore" Version="8.0.0" />
<PackageReference Include="Serilog.Sinks.Seq" Version="6.0.0" />
```

### Observability
```xml
<PackageReference Include="Microsoft.ApplicationInsights" Version="2.22.0" />
<PackageReference Include="OpenTelemetry.Extensions.Hosting" Version="1.7.0" />
<PackageReference Include="OpenTelemetry.Instrumentation.AspNetCore" Version="1.7.0" />
```

---

## üìÅ Estructura de Proyecto

```
src/
‚îú‚îÄ‚îÄ OrderService.Api/                    # Minimal API
‚îÇ   ‚îú‚îÄ‚îÄ Program.cs
‚îÇ   ‚îú‚îÄ‚îÄ Controllers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OrderController.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ OrderQueryController.cs
‚îÇ   ‚îú‚îÄ‚îÄ Middleware/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ExceptionHandlingMiddleware.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ LoggingMiddleware.cs
‚îÇ   ‚îî‚îÄ‚îÄ Extensions/
‚îÇ       ‚îú‚îÄ‚îÄ DependencyInjection.cs
‚îÇ       ‚îî‚îÄ‚îÄ ApiConfiguration.cs
‚îÇ
‚îú‚îÄ‚îÄ OrderService.Application/            # Application Layer
‚îÇ   ‚îú‚îÄ‚îÄ Commands/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CreateOrder/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CreateOrderCommand.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CreateOrderCommandHandler.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CreateOrderCommandValidator.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ MarkOrderAsPaid/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ MarkOrderAsPaidCommand.cs
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ MarkOrderAsPaidCommandHandler.cs
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ MarkOrderAsPaidCommandValidator.cs
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ Queries/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ GetOrderById/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ GetOrderByIdQuery.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ GetOrderByIdQueryHandler.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ GetAllOrders/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ GetAllOrdersQuery.cs
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ GetAllOrdersQueryHandler.cs
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ Events/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OrderPlacedEvent.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OrderPaidEvent.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ OrderCancelledEvent.cs
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ DTOs/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OrderDto.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OrderItemDto.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CreateOrderRequest.cs
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ Mappings/
‚îÇ       ‚îî‚îÄ‚îÄ OrderProfile.cs
‚îÇ
‚îú‚îÄ‚îÄ OrderService.Domain/                 # Domain Layer
‚îÇ   ‚îú‚îÄ‚îÄ Aggregates/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Order.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OrderItem.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ OrderStatus.cs
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ Events/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ IDomainEvent.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OrderCreatedEvent.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OrderItemAddedEvent.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ OrderPaidEvent.cs
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ ValueObjects/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Money.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Address.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Email.cs
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ Interfaces/
‚îÇ       ‚îú‚îÄ‚îÄ IOrderRepository.cs
‚îÇ       ‚îî‚îÄ‚îÄ IRepository.cs
‚îÇ
‚îú‚îÄ‚îÄ OrderService.Infrastructure/         # Infrastructure Layer
‚îÇ   ‚îú‚îÄ‚îÄ Persistence/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ WriteDbContext.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Configurations/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ OrderConfiguration.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Repositories/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ OrderRepository.cs
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ ReadModels/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OrderView.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OrderItemView.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ReadDbContext.cs
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ Projections/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ OrderProjection.cs
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ Messaging/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Consumers/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OrderPlacedConsumer.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ InventoryReservedConsumer.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Publishers/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ EventPublisher.cs
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ Caching/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ RedisCacheService.cs
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ External/
‚îÇ       ‚îú‚îÄ‚îÄ PaymentService.cs
‚îÇ       ‚îî‚îÄ‚îÄ InventoryService.cs
‚îÇ
‚îú‚îÄ‚îÄ OrderService.Sagas/                  # SAGA Orchestration
‚îÇ   ‚îú‚îÄ‚îÄ OrderProcessingSaga.cs
‚îÇ   ‚îú‚îÄ‚îÄ OrderProcessingSagaState.cs
‚îÇ   ‚îî‚îÄ‚îÄ SagaConfiguration.cs
‚îÇ
‚îî‚îÄ‚îÄ OrderService.Tests/                  # Tests
    ‚îú‚îÄ‚îÄ Unit/
    ‚îÇ   ‚îú‚îÄ‚îÄ Domain/
    ‚îÇ   ‚îú‚îÄ‚îÄ Application/
    ‚îÇ   ‚îî‚îÄ‚îÄ Infrastructure/
    ‚îÇ
    ‚îú‚îÄ‚îÄ Integration/
    ‚îÇ   ‚îî‚îÄ‚îÄ OrderIntegrationTests.cs
    ‚îÇ
    ‚îî‚îÄ‚îÄ E2E/
        ‚îî‚îÄ‚îÄ OrderWorkflowTests.cs
```

---

## üíª Implementaci√≥n

### 1. Setup B√°sico (Program.cs)

```csharp
using MediatR;
using MassTransit;
using Microsoft.EntityFrameworkCore;

var builder = WebApplication.CreateBuilder(args);

// Add services
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// Add MediatR
builder.Services.AddMediatR(cfg => cfg.RegisterServicesFromAssembly(typeof(Program).Assembly));

// Add DbContexts
builder.Services.AddDbContext<WriteDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("WriteDb")));

builder.Services.AddScoped<ReadDbContext>();

// Add Repositories
builder.Services.AddScoped<IOrderRepository, OrderRepository>();

// Add Caching
builder.Services.AddStackExchangeRedisCache(options =>
{
    options.Configuration = builder.Configuration.GetConnectionString("Redis");
});

// Add MassTransit (Messaging)
builder.Services.AddMassTransit(x =>
{
    x.AddSaga<OrderProcessingSaga>()
        .EntityFrameworkRepository(r =>
        {
            r.ExistingDbContext<WriteDbContext>();
            r.UseSqlServer();
        });
    
    x.AddConsumer<OrderPlacedConsumer>();
    x.AddConsumer<InventoryReservedConsumer>();
    
    x.UsingRabbitMq((context, cfg) =>
    {
        cfg.Host(builder.Configuration.GetConnectionString("RabbitMQ"));
        cfg.ConfigureEndpoints(context);
    });
});

// Add Logging
builder.Logging.ClearProviders();
builder.Logging.AddSerilog(new LoggerConfiguration()
    .WriteTo.Console()
    .WriteTo.Seq("http://localhost:5341")
    .CreateLogger());

var app = builder.Build();

// Configure pipeline
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();
app.UseMiddleware<ExceptionHandlingMiddleware>();
app.UseMiddleware<RequestLoggingMiddleware>();

// Map endpoints
app.MapPost("/api/orders", async (
    CreateOrderRequest request,
    IMediator mediator,
    CancellationToken ct) =>
{
    var command = new CreateOrderCommand
    {
        CustomerId = request.CustomerId,
        Items = request.Items,
        ShippingAddress = request.ShippingAddress
    };
    
    var result = await mediator.Send(command, ct);
    return Results.Ok(result);
})
.Produces<OrderDto>(StatusCodes.Status201Created)
.Produces(StatusCodes.Status400BadRequest);

app.MapGet("/api/orders/{id}", async (
    Guid id,
    IMediator mediator,
    CancellationToken ct) =>
{
    var query = new GetOrderByIdQuery { OrderId = id };
    var result = await mediator.Send(query, ct);
    return Results.Ok(result);
})
.Produces<OrderDto>()
.Produces(StatusCodes.Status404NotFound);

app.Run();
```

### 2. Domain Aggregate (Order.cs)

```csharp
public class Order : AggregateRoot
{
    public Guid Id { get; private set; }
    public Guid CustomerId { get; private set; }
    public decimal Total { get; private set; }
    public OrderStatus Status { get; private set; }
    public Address ShippingAddress { get; private set; }
    public DateTime CreatedAt { get; private set; }
    public DateTime? PaidAt { get; private set; }
    
    private readonly List<OrderItem> _items = new();
    public IReadOnlyCollection<OrderItem> Items => _items.AsReadOnly();
    
    private Order() { } // EF Core
    
    public static Order Create(Guid customerId, Address shippingAddress)
    {
        var order = new Order
        {
            Id = Guid.NewGuid(),
            CustomerId = customerId,
            ShippingAddress = shippingAddress,
            Status = OrderStatus.Draft,
            CreatedAt = DateTime.UtcNow
        };
        
        order.AddDomainEvent(new OrderCreatedEvent(order.Id, customerId));
        return order;
    }
    
    public void AddItem(ProductId productId, int quantity, decimal unitPrice)
    {
        if (Status != OrderStatus.Draft)
            throw new InvalidOperationException("Cannot modify order in current state");
        
        var item = new OrderItem(Id, productId, quantity, unitPrice);
        _items.Add(item);
        
        Total = _items.Sum(i => i.SubTotal);
        
        AddDomainEvent(new OrderItemAddedEvent(Id, productId, quantity, unitPrice));
    }
    
    public void MarkAsPaid(PaymentId paymentId)
    {
        if (Status != OrderStatus.Draft)
            throw new InvalidOperationException("Cannot pay order in current state");
        
        Status = OrderStatus.Paid;
        PaidAt = DateTime.UtcNow;
        
        AddDomainEvent(new OrderPaidEvent(Id, paymentId, Total));
    }
    
    public void MarkAsCompleted()
    {
        if (Status != OrderStatus.Paid)
            throw new InvalidOperationException("Cannot complete unpaid order");
        
        Status = OrderStatus.Completed;
        
        AddDomainEvent(new OrderCompletedEvent(Id));
    }
}
```

### 3. Command Handler

```csharp
public class CreateOrderCommand : IRequest<OrderDto>
{
    public Guid CustomerId { get; set; }
    public List<OrderItemDto> Items { get; set; }
    public Address ShippingAddress { get; set; }
}

public class CreateOrderCommandHandler : IRequestHandler<CreateOrderCommand, OrderDto>
{
    private readonly IOrderRepository _orderRepository;
    private readonly ILogger<CreateOrderCommandHandler> _logger;
    private readonly IPublishEndpoint _publishEndpoint;
    
    public CreateOrderCommandHandler(
        IOrderRepository orderRepository,
        ILogger<CreateOrderCommandHandler> logger,
        IPublishEndpoint publishEndpoint)
    {
        _orderRepository = orderRepository;
        _logger = logger;
        _publishEndpoint = publishEndpoint;
    }
    
    public async Task<OrderDto> Handle(CreateOrderCommand request, CancellationToken ct)
    {
        // 1. Create Aggregate
        var order = Order.Create(request.CustomerId, request.ShippingAddress);
        
        foreach (var item in request.Items)
        {
            order.AddItem(item.ProductId, item.Quantity, item.UnitPrice);
        }
        
        // 2. Persist Aggregate
        await _orderRepository.AddAsync(order, ct);
        await _orderRepository.SaveChangesAsync(ct);
        
        // 3. Publish Domain Events (para proyecciones)
        var events = order.DomainEvents;
        foreach (var @event in events)
        {
            await _publishEndpoint.Publish(@event, ct);
        }
        
        order.ClearDomainEvents();
        
        _logger.LogInformation("Order {OrderId} created for customer {CustomerId}", 
            order.Id, order.CustomerId);
        
        // 4. Return DTO
        return new OrderDto
        {
            Id = order.Id,
            CustomerId = order.CustomerId,
            Total = order.Total,
            Status = order.Status.ToString(),
            Items = order.Items.Select(i => new OrderItemDto
            {
                ProductId = i.ProductId,
                Quantity = i.Quantity,
                UnitPrice = i.UnitPrice
            }).ToList(),
            CreatedAt = order.CreatedAt
        };
    }
}
```

### 4. Query Handler (Read Model)

```csharp
public class GetOrderByIdQuery : IRequest<OrderDto>
{
    public Guid OrderId { get; set; }
}

public class GetOrderByIdQueryHandler : IRequestHandler<GetOrderByIdQuery, OrderDto>
{
    private readonly ReadDbContext _readDb;
    private readonly IMemoryCache _cache;
    
    public GetOrderByIdQueryHandler(ReadDbContext readDb, IMemoryCache cache)
    {
        _readDb = readDb;
        _cache = cache;
    }
    
    public async Task<OrderDto> Handle(GetOrderByIdQuery request, CancellationToken ct)
    {
        // 1. Try cache first
        var cacheKey = $"order:{request.OrderId}";
        if (_cache.TryGetValue<OrderDto>(cacheKey, out var cached))
        {
            return cached;
        }
        
        // 2. Query from Read DB (Dapper - optimized for reads)
        var sql = @"
            SELECT 
                o.Id,
                o.CustomerId,
                o.Total,
                o.Status,
                o.CreatedAt,
                o.PaidAt,
                oi.ProductId,
                oi.ProductName,
                oi.Quantity,
                oi.UnitPrice,
                oi.SubTotal
            FROM OrderView o
            LEFT JOIN OrderItemView oi ON o.Id = oi.OrderId
            WHERE o.Id = @OrderId
        ";
        
        var orderDict = new Dictionary<Guid, OrderDto>();
        
        await _readDb.Connection.QueryAsync<OrderDto, OrderItemDto, OrderDto>(
            sql,
            (order, item) =>
            {
                if (!orderDict.TryGetValue(order.Id, out var orderEntry))
                {
                    orderEntry = order;
                    orderEntry.Items = new List<OrderItemDto>();
                    orderDict.Add(order.Id, orderEntry);
                }
                
                if (item != null)
                {
                    orderEntry.Items.Add(item);
                }
                
                return orderEntry;
            },
            new { OrderId = request.OrderId },
            splitOn: "ProductId"
        );
        
        if (!orderDict.TryGetValue(request.OrderId, out var result))
        {
            throw new NotFoundException($"Order {request.OrderId} not found");
        }
        
        // 3. Cache for 5 minutes
        _cache.Set(cacheKey, result, TimeSpan.FromMinutes(5));
        
        return result;
    }
}
```

### 5. Projection Handler

```csharp
public class OrderProjection : IConsumer<OrderPlacedEvent>
{
    private readonly ReadDbContext _readDb;
    private readonly ILogger<OrderProjection> _logger;
    
    public OrderProjection(ReadDbContext readDb, ILogger<OrderProjection> logger)
    {
        _readDb = readDb;
        _logger = logger;
    }
    
    public async Task Consume(ConsumeContext<OrderPlacedEvent> context)
    {
        var @event = context.Message;
        
        // Update Read Model
        var orderView = new OrderView
        {
            Id = @event.OrderId,
            CustomerId = @event.CustomerId,
            Total = @event.Total,
            Status = "Draft",
            CreatedAt = @event.OccurredAt,
            ItemCount = @event.Items.Count,
            Discount = CalculateDiscount(@event.Items)
        };
        
        await _readDb.OrderViews.AddAsync(orderView);
        
        foreach (var item in @event.Items)
        {
            var itemView = new OrderItemView
            {
                OrderId = @event.OrderId,
                ProductId = item.ProductId,
                ProductName = item.ProductName,
                Quantity = item.Quantity,
                UnitPrice = item.UnitPrice,
                SubTotal = item.SubTotal,
                Category = item.Category  // Pre-joined
            };
            
            await _readDb.OrderItemViews.AddAsync(itemView);
        }
        
        await _readDb.SaveChangesAsync();
        
        _logger.LogInformation("Projection updated for order {OrderId}", @event.OrderId);
    }
}
```

---

## üîÑ Casos de Uso

### Caso 1: Crear Orden (Write)

```csharp
// Request
POST /api/orders
{
    "customerId": "123e4567-e89b-12d3-a456-426614174000",
    "items": [
        {
            "productId": "789e4567-e89b-12d3-a456-426614174001",
            "quantity": 2,
            "unitPrice": 99.99
        }
    ],
    "shippingAddress": {
        "street": "123 Main St",
        "city": "New York",
        "zipCode": "10001"
    }
}

// Flow:
// 1. API ‚Üí CreateOrderCommand
// 2. MediatR ‚Üí CreateOrderCommandHandler
// 3. Handler ‚Üí Order.Create() (Aggregate)
// 4. Handler ‚Üí Repository.Save()
// 5. Handler ‚Üí Publish Domain Events
// 6. Event Bus ‚Üí OrderProjection (Update Read Model)
// 7. API ‚Üí Return OrderDto
```

### Caso 2: Consultar Orden (Read)

```csharp
// Request
GET /api/orders/123e4567-e89b-12d3-a456-426614174000

// Flow:
// 1. API ‚Üí GetOrderByIdQuery
// 2. MediatR ‚Üí GetOrderByIdQueryHandler
// 3. Handler ‚Üí Check Cache
// 4. Handler ‚Üí Query Read DB (Dapper)
// 5. Handler ‚Üí Cache result
// 6. API ‚Üí Return OrderDto
```

### Caso 3: Procesar Orden Completa (SAGA)

```csharp
// Flow:
// 1. OrderPlacedEvent ‚Üí OrderProcessingSaga iniciada
// 2. Saga ‚Üí Publish ReserveInventoryCommand
// 3. Inventory Service ‚Üí Reserve inventory
// 4. Inventory Service ‚Üí Publish InventoryReservedEvent
// 5. Saga ‚Üí Publish ProcessPaymentCommand
// 6. Payment Service ‚Üí Charge customer
// 7. Payment Service ‚Üí Publish PaymentProcessedEvent
// 8. Saga ‚Üí Publish OrderCompletedEvent
// 9. Order Service ‚Üí Mark order as completed
```

---

## ü§ñ Consideraciones para Agentes de IA

### Patrones Clave a Entender

1. **Siempre separar Write y Read**
   - Write: Use Aggregates (EF Core)
   - Read: Use DTOs (Dapper)

2. **Los eventos son el pegamento**
   - Todo cambio de estado genera un evento
   - Los eventos actualizan proyecciones autom√°ticamente

3. **SAGA maneja transacciones distribuidas**
   - No uses transacciones ACID distribuidas
   - Usa compensaciones (rollback manual)

4. **Optimiza Reads agresivamente**
   - Pre-c√°lculo
   - Denormalizaci√≥n
   - Caching

### Comandos √ötiles

```bash
# Crear migraci√≥n (Write DB)
dotnet ef migrations add AddOrderStatus --project OrderService.Infrastructure --startup-project OrderService.Api

# Aplicar migraci√≥n
dotnet ef database update --project OrderService.Infrastructure --startup-project OrderService.Api

# Ejecutar tests
dotnet test --verbosity normal

# Observar logs en Seq
# Ir a http://localhost:5341
```

### Red Flags a Evitar

‚ùå **Mezclar Write y Read en el mismo handler**
```csharp
// MAL
public async Task<OrderDto> Handle(CreateOrderCommand request)
{
    var order = Order.Create(...);
    await SaveOrder(order);
    
    // MAL: Leer de la misma DB donde acabas de escribir
    var savedOrder = await ReadOrder(order.Id);
    return savedOrder;
}
```

‚ùå **Usar EF Core para Reads**
```csharp
// MAL: Muy lento
var orders = await _context.Orders
    .Include(o => o.Items)
    .Include(o => o.Customer)
    .Where(o => o.Status == "Paid")
    .ToListAsync();
```

‚ùå **Transacciones distribuidas ACID**
```csharp
// MAL: No funciona en microservicios
using var transaction = scope.BeginTransaction();
await ReserveInventory();
await ChargePayment();
transaction.Commit();
```

‚úÖ **En lugar de eso:**
- Usa Dapper para reads
- Usa SAGA para transacciones distribuidas
- Usa proyecciones para mantener consistencia eventual

---

## üìä M√©tricas de √âxito

- **Write Latency**: < 50ms (p95)
- **Read Latency**: < 10ms (p95)
- **Throughput**: > 10,000 req/s (reads)
- **Consistency Window**: < 1 segundo (eventual)
- **Availability**: 99.9%

---

## üîó Recursos Adicionales

- [Martin Fowler - CQRS](https://martinfowler.com/bliki/CQRS.html)
- [MassTransit Documentation](https://masstransit.io/)
- [MediatR Library](https://github.com/jbogard/MediatR)
- [EF Core Best Practices](https://learn.microsoft.com/en-us/ef/core/performance/)

---

**Filosof√≠a Final:** "Separa para dominar. Optimiza reads y writes por separado. Usa eventos para la consistencia eventual. Los SAGAs manejan las transacciones distribuidas. El rendimiento viene de la arquitectura, no del hardware."

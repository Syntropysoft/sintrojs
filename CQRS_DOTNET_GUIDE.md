# SintroNet - Gu√≠a de Implementaci√≥n
## Framework Minimalista para CQRS + SAGA + Event-Driven en .NET

> **Filosof√≠a:** "Minimal en configuraci√≥n. M√°ximo en potencia. La complejidad empresarial reducida a APIs declarativas."

---

## üìö √çndice

1. [Visi√≥n General](#visi√≥n-general)
2. [El Problema que Resolvemos](#el-problema-que-resolvemos)
3. [Soluci√≥n: API Declarativa](#soluci√≥n-api-declarativa)
4. [Similitudes con SyntroJS](#similitudes-con-syntrojs)
5. [Ventajas Exclusivas de .NET](#ventajas-exclusivas-de-net)
6. [Swagger y Documentaci√≥n Autom√°tica](#swagger-y-documentaci√≥n-autom√°tica)
7. [Observabilidad y Logging](#observabilidad-y-logging)
8. [Arquitectura Interna](#arquitectura-interna)
9. [Stack Tecnol√≥gico](#stack-tecnol√≥gico)
10. [Implementaci√≥n Detallada](#implementaci√≥n-detallada)
11. [Consideraciones para Agentes de IA](#consideraciones-para-agentes-de-ia)

---

## üéØ Visi√≥n General

**SintroNet** es una librer√≠a de .NET que abstrae toda la complejidad de arquitectura empresarial (CQRS, SAGAs, Event-Driven, Proyecciones) detr√°s de una API declarativa extremadamente simple, inspirada en **SyntroJS** pero aprovechando las ventajas √∫nicas de .NET.

### Principios Fundamentales

1. **Configuraci√≥n Declarativa**: El usuario define QU√â necesita, la librer√≠a maneja C√ìMO
2. **Abstracci√≥n Total**: CQRS, SAGAs, eventos, proyecciones son impl√≠citos
3. **Zero Boilerplate**: No hay CommandHandlers, QueryHandlers, EventHandlers manuales
4. **Auto-Orchestration**: SAGAs se generan autom√°ticamente desde la configuraci√≥n
5. **Type-Safe**: Todo fuertemente tipado con compilaci√≥n est√°tica
6. **Observability First**: Logging, m√©tricas y tracing con m√≠nima configuraci√≥n
7. **Swagger Integrado**: OpenAPI y documentaci√≥n interactiva autom√°tica
8. **Performance Nativo**: Aprovecha .NET para m√°ximo rendimiento

---

## ‚ùå El Problema que Resolvemos

### C√≥digo Tradicional (Sin Framework)

```csharp
// ‚ùå El usuario necesita escribir MILES de l√≠neas:

// 1. Domain Aggregate
public class Order : AggregateRoot { /* 100+ l√≠neas */ }

// 2. Command
public class CreateOrderCommand : IRequest<OrderDto> { }

// 3. Command Handler
public class CreateOrderCommandHandler : IRequestHandler<CreateOrderCommand, OrderDto> 
{ 
    /* 50+ l√≠neas de l√≥gica boilerplate */
}

// 4. Query
public class GetOrderByIdQuery : IRequest<OrderDto> { }

// 5. Query Handler
public class GetOrderByIdQueryHandler : IRequestHandler<GetOrderByIdQuery, OrderDto>
{
    /* 50+ l√≠neas de l√≥gica boilerplate */
}

// 6. Event Handlers
public class OrderPlacedEventHandler : IEventHandler<OrderPlacedEvent> { }
public class OrderProjectionHandler : IConsumer<OrderPlacedEvent> { }

// 7. SAGA
public class OrderProcessingSaga : ISaga { /* 200+ l√≠neas */ }

// 8. DTOs, Mappings, Configuraciones...
// TOTAL: 2000+ l√≠neas para una entidad simple
```

---

## ‚úÖ Soluci√≥n: API Declarativa

### C√≥digo con SyntroJS for .NET

```csharp
// ‚úÖ El usuario escribe SOLO 20 l√≠neas:

using SyntroJS;

var app = SyntroApp.Create();

// Definir entidad Order con configuraci√≥n declarativa
app.Entity<Order>()
    .Write(model => model
        .Aggregate<OrderAggregate>()  // La librer√≠a crea el aggregate
        .AutoCreateEndpoint()          // POST /api/orders
        .AutoUpdateEndpoint()          // PUT /api/orders/{id}
        .AutoDeleteEndpoint()          // DELETE /api/orders/{id}
        .OnCreated("OrderPlaced")      // Emite evento autom√°ticamente
    )
    .Read(model => model
        .AutoGetByIdEndpoint()         // GET /api/orders/{id}
        .AutoListEndpoint()            // GET /api/orders
        .AutoSearchEndpoint()          // GET /api/orders?search=...
        .Projection<OrderView>()       // Proyecci√≥n autom√°tica
        .Cache(duration: 5.Minutes())  // Cache autom√°tico
    )
    .Saga("OrderProcessing", saga => saga
        .Step<OrderPlacedEvent>(async (ctx, next) =>
        {
            // Reservar inventario
            await ReserveInventory(ctx.Order.Items);
            await ctx.Publish("InventoryReserved");
        })
        .Step<InventoryReservedEvent>(async (ctx, next) =>
        {
            // Procesar pago
            await ProcessPayment(ctx.Order.Total);
            await ctx.Publish("PaymentProcessed");
        })
        .Step<PaymentProcessedEvent>(async (ctx, next) =>
        {
            // Completar orden
            await CompleteOrder(ctx.OrderId);
        })
        .Compensate(async (ctx) =>
        {
            // Rollback autom√°tico si falla
            await ReleaseInventory(ctx.Order.Items);
        })
    );

app.Run();
```

**Lo que la librer√≠a genera autom√°ticamente:**
- ‚úÖ Commands y Command Handlers
- ‚úÖ Queries y Query Handlers
- ‚úÖ Event Handlers
- ‚úÖ Projections
- ‚úÖ SAGA completa con compensaci√≥n
- ‚úÖ Endpoints REST
- ‚úÖ Validaci√≥n autom√°tica
- ‚úÖ Mapeos DTO ‚Üî Aggregate
- ‚úÖ Migraciones EF Core
- ‚úÖ Queries optimizadas con Dapper
- ‚úÖ OpenAPI/Swagger autom√°tico
- ‚úÖ Logging estructurado
- ‚úÖ M√©tricas y trazabilidad

---

## üîÑ Similitudes con SyntroJS

### API Fluent Similar

**SintroNet** toma inspiraci√≥n directa de **SyntroJS**:

#### SyntroJS (TypeScript/Node.js)
```typescript
app.post('/orders', {
  body: OrderSchema,
  status: 201,
  dependencies: { db: inject(getDatabase) },
  handler: ({ body, dependencies }) => 
    dependencies.db.orders.create(body)
});
```

#### SintroNet (C#)
```csharp
app.Entity<Order>()
    .Write(model => model
        .AutoCreateEndpoint()  // POST /api/orders
        .UseAggregate<OrderAggregate>()
        .Dependencies(db => db.Use<Database>())
    );
```

### Caracter√≠sticas Compartidas

| Caracter√≠stica | SyntroJS | SintroNet |
|----------------|----------|-----------|
| **API Declarativa** | ‚úÖ | ‚úÖ |
| **Zero Boilerplate** | ‚úÖ | ‚úÖ |
| **Dependency Injection** | ‚úÖ | ‚úÖ |
| **Validaci√≥n Autom√°tica** | ‚úÖ | ‚úÖ |
| **OpenAPI/Swagger** | ‚úÖ | ‚úÖ |
| **Type-Safe** | ‚úÖ TypeScript | ‚úÖ C# Strong Typing |
| **Event-Driven** | ‚úÖ | ‚úÖ |
| **CQRS** | Manual | ‚úÖ Auto-generado |
| **SAGAs** | Manual | ‚úÖ Auto-orquestadas |

---

## üöÄ Ventajas Exclusivas de .NET

### 1. Compilaci√≥n Est√°tica
```csharp
// ‚ùå Error en COMPILACI√ìN, no en runtime
app.Entity<Order>()
    .Write(model => model
        .AutoCreateEndpoint()
        .InvalidMethod()  // ‚Üê Errores detectados en dev
    );
```

### 2. Performance Nativo
```csharp
// .NET compilado a m√°quina nativa
// - 10x m√°s r√°pido que Node.js para CPU-bound
// - Menor consumo de memoria
// - Mejor latencia
```

### 3. Tooling Ecosystem
```csharp
// JetBrains Rider / Visual Studio
// - IntelliSense perfecto
// - Refactoring autom√°tico
// - Debug visual
// - Profiling integrado
```

### 4. Generics y Type System Avanzado
```csharp
// Type inference extremo
app.Entity<Order>()
    .Read(model => model
        .AutoGetByIdEndpoint<Guid>()  // Type inferido
        .AutoListEndpoint()            // PagedResponse<T> inferido
        .AutoSearchEndpoint(query => query
            .Where(o => o.Total > 100)  // Expression trees compiladas
        )
    );
```

### 5. Null Safety
```csharp
// C# 11 nullable reference types
public record OrderDto(
    Guid Id,
    string CustomerName,  // Non-nullable
    string? Notes        // Nullable expl√≠cito
);
```

### 6. Pattern Matching Avanzado
```csharp
app.Entity<Order>()
    .Saga("OrderProcessing", saga => saga
        .Step<OrderPlacedEvent>(async ctx => 
            ctx.Order.Status switch
            {
                OrderStatus.Draft => await ProcessDraft(ctx),
                OrderStatus.Pending => await ProcessPending(ctx),
                _ => throw new InvalidOperationException()
            }
        )
    );
```

---

## üìã Swagger y Documentaci√≥n Autom√°tica

### Auto-Generaci√≥n de OpenAPI

**SintroNet** genera autom√°ticamente OpenAPI 3.0 desde la configuraci√≥n declarativa:

```csharp
var app = SyntroApp.Create()
    .EnableSwagger(config => config
        .Title("E-Commerce API")
        .Description("API for managing orders and products")
        .Version("v1")
        .AddServer("https://api.example.com")
        .AddServer("https://staging.example.com", "Staging")
    );

app.Entity<Order>()
    .Write(model => model
        .AutoCreateEndpoint()
        .Summary("Create a new order")
        .Description("Allows customers to create orders")
        .ProducesResponse<OrderDto>(201, "Order created successfully")
        .ProducesResponse(400, "Validation error")
    )
    .Read(model => model
        .AutoGetByIdEndpoint()
        .Summary("Get order by ID")
        .ProducesResponse<OrderDto>(200, "Order found")
        .ProducesResponse(404, "Order not found")
    );
```

### UI Interactiva

```
GET /swagger        ‚Üí Swagger UI (interactive)
GET /swagger/v1/swagger.json  ‚Üí OpenAPI spec
GET /redoc         ‚Üí ReDoc (alternative UI)
```

### Documentaci√≥n Autom√°tica

```csharp
public record OrderDto(
    /// <summary>Unique order identifier</summary>
    /// <example>123e4567-e89b-12d3-a456-426614174000</example>
    Guid Id,
    
    /// <summary>Customer ID who placed the order</summary>
    Guid CustomerId,
    
    /// <summary>Total amount including tax</summary>
    /// <example>99.99</example>
    decimal Total,
    
    /// <summary>Order status</summary>
    /// <example>Pending</example>
    OrderStatus Status
);
```

---

## üìä Observabilidad y Logging

### Logging Estructurado Autom√°tico

```csharp
var app = SyntroApp.Create()
    .UseLogger(config => config
        .AddConsole()                    // Console logs
        .AddSeq("http://localhost:5341")  // Seq aggregation
        .AddApplicationInsights()         // Azure telemetry
        .SetMinimumLevel(LogLevel.Information)
    );

// Los logs se generan autom√°ticamente:
// [INFO] Order created: { OrderId: "abc", CustomerId: "xyz", Total: 99.99 }
// [INFO] Command processed: CreateOrderCommand in 45ms
// [ERROR] Validation failed: { Field: "CustomerId", Error: "Required" }
```

### Logging a Demanda

```csharp
app.Entity<Order>()
    .Write(model => model
        .AutoCreateEndpoint()
        .LogRequest()     // Log incoming requests
        .LogResponse()    // Log outgoing responses
        .LogPerformance() // Log execution time
        .LogErrors()      // Log exceptions
    );
```

### M√©tricas Autom√°ticas

```csharp
var app = SyntroApp.Create()
    .UseMetrics(config => config
        .Counter("orders_created_total")
        .Histogram("order_processing_duration_ms")
        .Gauge("active_orders_count")
    );

// M√©tricas expuestas autom√°ticamente en /metrics (Prometheus format)
```

### Distributed Tracing

```csharp
var app = SyntroApp.Create()
    .UseTracing(config => config
        .AddOpenTelemetry()  // OpenTelemetry est√°ndar
        .AddJaeger()         // Jaeger integration
        .AddZipkin()         // Zipkin integration
    );

// Traces autom√°ticos para:
// - Request lifecycle
// - Database queries
// - External API calls
// - SAGA steps
// - Event publishing
```

### Observabilidad Completa

```csharp
var app = SyntroApp.Create()
    .EnableObservability(config => config
        .RequestId()              // Correlation IDs
        .UserAgent()              // Client info
        .Duration()               // Request duration
        .StatusCodes()            // Response codes
        .ExceptionDetails()       // Stack traces
        .CustomTags(tags => tags  // Custom metadata
            .Add("environment", "production")
            .Add("version", "1.0.0")
        )
    );
```

---

## üèóÔ∏è Arquitectura Interna

La librer√≠a internamente organiza todo como arquitectura CQRS/SAGA:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   SyntroApp (User Code)                     ‚îÇ
‚îÇ  app.Entity<Order>().Write().Read().Saga()                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              SyntroJS.Core (Library Core)                   ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ
‚îÇ  ‚îÇ  EntityRegistry: Convierte configuraci√≥n       ‚îÇ        ‚îÇ
‚îÇ  ‚îÇ  declarativa en arquitectura CQRS              ‚îÇ        ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ
‚îÇ  ‚îÇ  CommandGenerator: Genera Commands + Handlers  ‚îÇ        ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ
‚îÇ  ‚îÇ  QueryGenerator: Genera Queries + Handlers     ‚îÇ        ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ
‚îÇ  ‚îÇ  ProjectionGenerator: Genera proyecciones      ‚îÇ        ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ
‚îÇ  ‚îÇ  SagaGenerator: Genera SAGAs con compensaci√≥n  ‚îÇ        ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ          SyntroJS.Infrastructure (Generated Code)           ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îÇ
‚îÇ  ‚îÇ  Commands/       ‚îÇ  ‚îÇ  Queries/        ‚îÇ                ‚îÇ
‚îÇ  ‚îÇ  Handlers        ‚îÇ  ‚îÇ  Handlers        ‚îÇ                ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îÇ
‚îÇ  ‚îÇ  Events/         ‚îÇ  ‚îÇ  Sagas/          ‚îÇ                ‚îÇ
‚îÇ  ‚îÇ  Projections     ‚îÇ  ‚îÇ  Orchestration   ‚îÇ                ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              MassTransit + MediatR + EF Core                ‚îÇ
‚îÇ              (Orquestaci√≥n, Event Bus, Persistence)         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üîê Idempotencia Autom√°tica (Inbox Pattern)

### El Problema de Mensajes Duplicados

En sistemas distribuidos basados en eventos, los message brokers garantizan entrega "at-least-once" (al menos una vez). Esto significa que el mismo mensaje puede entregarse m√∫ltiples veces.

**Consecuencias sin Idempotencia:**
```csharp
// ‚ùå Sin idempotencia: Procesar pago DOS veces
PaymentProcessedEvent (ID: "abc-123") ‚Üí Procesar $100
PaymentProcessedEvent (ID: "abc-123") ‚Üí Procesar $100 OTRA VEZ ‚ùå

// Cliente cobrado $200 en lugar de $100
```

### Soluci√≥n: Inbox Pattern Autom√°tico

**SintroNet** implementa autom√°ticamente el **Inbox Pattern**, garantizando que cada mensaje se procese exactamente una vez:

```csharp
app.Entity<Order>()
    .Write(model => model
        .AutoCreateEndpoint()
        .WithIdempotency()  // ‚Üê Una sola l√≠nea habilita idempotencia
    );

// Tambi√©n funciona en SAGAs
app.Saga("OrderProcessing", saga => saga
    .Step<PaymentProcessedEvent>(async (ctx, next) => 
    {
        await ProcessPayment(ctx.Amount);
    })
    .WithIdempotency()  // ‚Üê Protege contra duplicados
);
```

### ¬øC√≥mo Funciona Internamente?

La librer√≠a mantiene una tabla `inbox_messages`:

```sql
CREATE TABLE inbox_messages (
    id UUID PRIMARY KEY,        -- Message ID √∫nico
    handler_name VARCHAR(255),  -- Handler que procesa el mensaje
    processed_at TIMESTAMP,     -- Cu√°ndo se proces√≥
    payload TEXT                -- Serializaci√≥n del mensaje
);
```

**Flujo Autom√°tico:**
1. Mensaje llega con ID `"abc-123"`
2. Librer√≠a verifica: `SELECT * FROM inbox_messages WHERE id = 'abc-123'`
3. Si existe ‚Üí Ignora mensaje (ya procesado)
4. Si no existe ‚Üí Procesa mensaje y guarda en `inbox_messages`

### Configuraci√≥n Avanzada

```csharp
app.UseInbox(config => config
    .Provider<SqlServerInbox>()  // PostgreSQL, MySQL, etc.
    .RetentionDays(90)            // Limpiar mensajes antiguos
    .BatchSize(100)                // Procesar en lotes
);
```

**Beneficios:**
- ‚úÖ Garant√≠a de procesamiento exactamente-una-vez
- ‚úÖ Zero configuraci√≥n por default
- ‚úÖ Transparente para el desarrollador
- ‚úÖ Soporte multi-provider (SQL, MongoDB, etc.)

---

## üì¶ Event Sourcing (Opcional)

### ¬øQu√© es Event Sourcing?

**Event Sourcing** es una estrategia de persistencia donde en lugar de guardar el **estado actual** del agregado, guardamos la **secuencia inmutable de eventos** que ocurrieron.

### Comparaci√≥n: Estado vs Eventos

| Aspecto | Estado Tradicional | Event Sourcing |
|---------|-------------------|----------------|
| **Persistencia** | Tabla `Orders` con estado actual | Tabla `events` con historia |
| **Queries** | ‚úÖ Directo (SELECT * FROM Orders) | ‚ùå Requiere replay eventos |
| **Auditor√≠a** | ‚ùå Limitada (solo estado actual) | ‚úÖ Historial completo |
| **Time Travel** | ‚ùå Imposible | ‚úÖ Ver estado en cualquier momento |
| **Nuevas Proyecciones** | ‚ùå Requiere migraci√≥n | ‚úÖ Replay eventos hist√≥ricos |
| **Debugging** | ‚ùå Solo estado actual | ‚úÖ Ver exactamente qu√© pas√≥ |

### API Declarativa con Event Sourcing

```csharp
app.Entity<Order>()
    .Write(model => model
        .UseEventSourcing()        // ‚Üê Habilita Event Sourcing
        .AutoCreateEndpoint()
        .SnapshotEvery(100)        // Performance: snapshot cada 100 eventos
    );
```

### Flujo Interno

```csharp
// 1. Comando llega: CreateOrderCommand
var command = new CreateOrderCommand { CustomerId = "abc", Items = [...] };

// 2. Librer√≠a reconstruye agregado (si existe)
var order = await eventStore.GetAggregate<Order>(orderId);
// Reproduce eventos: OrderCreated ‚Üí OrderItemAdded ‚Üí OrderPaid

// 3. Ejecuta l√≥gica de negocio
order.AddItem(newItem);

// 4. Guarda NUEVO evento (no actualiza estado)
await eventStore.AppendEvent(new OrderItemAddedEvent { ... });
```

### Configuraci√≥n

```csharp
app.UseEventStore(config => config
    .Provider<PostgresEventStore>()  // o SQL Server, MongoDB
    .EnableSnapshots()                // Performance
    .RetentionPolicy(years: 7)        // Retenci√≥n hist√≥rica
);
```

**Casos de Uso:**
- ‚úÖ Sistemas financieros (auditor√≠a completa requerida)
- ‚úÖ Sistemas de compliance (historial inmutable)
- ‚úÖ Analytics y machine learning (todos los eventos hist√≥ricos)
- ‚úÖ Domain Events complejos (workflow rastreado)

---

## üîÑ Evoluci√≥n de Esquemas de Eventos

### El Problema del Versionado

Los eventos evolucionan con el tiempo:
```csharp
// Versi√≥n 1 (t0)
public record OrderPlacedEvent(
    Guid OrderId,
    Guid CustomerId,
    decimal Total
);

// Versi√≥n 2 (t1) - Campo nuevo a√±adido
public record OrderPlacedEvent(
    Guid OrderId,
    Guid CustomerId,
    decimal Total,
    string? DiscountCode  // ‚Üê Nuevo campo
);
```

**Problema:** Consumidores antiguos procesando eventos nuevos rompen.

### Estrategias

#### 1. Tolerant Reader (Recomendado)

Dise√±a consumidores que ignoren campos desconocidos:

```csharp
public class OrderProjection : IEventHandler<OrderPlacedEvent>
{
    public async Task Handle(OrderPlacedEvent @event)
    {
        // ‚úÖ IGNORA campos desconocidos
        // @event.DiscountCode ser√° null para eventos v1, OK!
        
        await UpdateProjection(@event.OrderId, @event.CustomerId, @event.Total);
    }
}
```

#### 2. Campos Opcionales Siempre

```csharp
// ‚úÖ BIEN: Nuevos campos siempre opcionales
public record OrderPlacedEvent(
    Guid OrderId,
    string? DiscountCode = null,  // ‚Üê Nullable con default
    Guid? CampaignId = null
);
```

#### 3. Upcasting Autom√°tico

**SintroNet** puede convertir eventos v1 a v2 autom√°ticamente:

```csharp
app.Events(config => config
    .Upcast<OrderPlacedEventV1, OrderPlacedEventV2>(v1 => new OrderPlacedEventV2
    {
        OrderId = v1.OrderId,
        CustomerId = v1.CustomerId,
        Total = v1.Total,
        DiscountCode = null  // ‚Üê Valor por defecto
    })
);
```

**Flujo:**
1. Evento v1 deserializado desde almacenamiento
2. Upcaster convierte a v2 en memoria
3. Handler recibe evento v2
4. Transparente para consumidor

#### 4. Versionado en Nombre (Breaking Changes)

Para cambios incompatibles:

```csharp
// Eventos completamente diferentes
public record OrderPlacedV2Event(...) { }
public record OrderPlacedV3Event(...) { }

// Consumidores espec√≠ficos
app.Consume<OrderPlacedV2Event>(...)
app.Consume<OrderPlacedV3Event>(...)
```

### Mejores Pr√°cticas

1. **Siempre** a√±ade campos opcionales
2. **Nunca** elimines campos existentes
3. **Usa** Tolerant Reader por defecto
4. **Documenta** cambios de schema
5. **Versiona** para breaking changes

---

## üéº SAGAs: Orquestaci√≥n vs Coreograf√≠a

### Orquestaci√≥n (Centralizada)

Una clase central orquesta el flujo completo:

```csharp
app.Saga("OrderProcessing", saga => saga
    .Orchestration()  // ‚Üê Modo orquestado
    .Step<OrderPlacedEvent>(async (ctx, next) => 
    {
        await ReserveInventory(ctx);
        await ctx.Publish("InventoryReserved");
    })
    .Step<InventoryReservedEvent>(async (ctx, next) => 
    {
        await ProcessPayment(ctx);
        await ctx.Publish("PaymentProcessed");
    })
);
```

**Caracter√≠sticas:**
- ‚úÖ Flujo centralizado y f√°cil de entender
- ‚úÖ Monitoreo en un solo lugar
- ‚úÖ L√≥gica de compensaci√≥n compleja
- ‚ùå Acoplamiento entre servicios

**Ideal para:** Workflows complejos (3+ pasos), transacciones cr√≠ticas

### Coreograf√≠a (Descentralizada)

Cada servicio reacciona a eventos publicados:

```csharp
// Order Service
app.Consume<PaymentProcessedEvent>(async (@event) => 
{
    await MarkOrderAsCompleted(@event.OrderId);
});

// Inventory Service
app.Consume<OrderPlacedEvent>(async (@event) => 
{
    await ReserveInventory(@event.Items);
    await ctx.Publish("InventoryReserved");
});

// Payment Service
app.Consume<InventoryReservedEvent>(async (@event) => 
{
    await ChargeCustomer(@event.OrderId);
    await ctx.Publish("PaymentProcessed");
});
```

**Caracter√≠sticas:**
- ‚úÖ Desacoplamiento total
- ‚úÖ Autonom√≠a de servicios
- ‚úÖ Escalabilidad independiente
- ‚ùå Flujo distribuido (m√°s dif√≠cil debuggear)

**Ideal para:** Workflows simples (2-3 pasos), microservicios independientes

### Decisi√≥n

| Criterio | Orquestaci√≥n | Coreograf√≠a |
|----------|--------------|-------------|
| **Complejidad** | Alta | Baja |
| **Pasos** | 3+ | 1-3 |
| **Compensaci√≥n** | Compleja | Simple |
| **Desacoplamiento** | Medio | Alto |
| **Debugging** | F√°cil | Dif√≠cil |
| **Monitoreo** | Centralizado | Distribuido |

**Recomendaci√≥n:** Orquestaci√≥n para workflows cr√≠ticos, Coreograf√≠a para notificaciones simples.

---

## üõ†Ô∏è Stack Tecnol√≥gico

### Core Framework
```xml
<PackageReference Include="Microsoft.NET" Version="8.0" />
<PackageReference Include="MediatR" Version="12.2.0" />
<PackageReference Include="FluentValidation" Version="11.9.0" />
<PackageReference Include="AutoMapper" Version="12.0.1" />
```

### Persistence
```xml
<!-- Write Database -->
<PackageReference Include="Microsoft.EntityFrameworkCore" Version="8.0.0" />
<PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" Version="8.0.0" />
<PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="8.0.0" />

<!-- Read Database (Dapper) -->
<PackageReference Include="Dapper" Version="2.1.24" />
<PackageReference Include="System.Data.SqlClient" Version="4.8.6" />

<!-- Caching -->
<PackageReference Include="StackExchange.Redis" Version="2.7.10" />
```

### Messaging
```xml
<PackageReference Include="MassTransit" Version="8.1.3" />
<PackageReference Include="MassTransit.RabbitMQ" Version="8.1.3" />
<!-- O alternativamente: -->
<PackageReference Include="MassTransit.Azure.ServiceBus.Core" Version="8.1.3" />
```

### API
```xml
<PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="8.0.0" />
<PackageReference Include="Swashbuckle.AspNetCore" Version="6.5.0" />
<PackageReference Include="Serilog.AspNetCore" Version="8.0.0" />
<PackageReference Include="Serilog.Sinks.Seq" Version="6.0.0" />
```

### Observability
```xml
<PackageReference Include="Microsoft.ApplicationInsights" Version="2.22.0" />
<PackageReference Include="OpenTelemetry.Extensions.Hosting" Version="1.7.0" />
<PackageReference Include="OpenTelemetry.Instrumentation.AspNetCore" Version="1.7.0" />
```

---

## üìÅ Estructura de Proyecto

```
src/
‚îú‚îÄ‚îÄ OrderService.Api/                    # Minimal API
‚îÇ   ‚îú‚îÄ‚îÄ Program.cs
‚îÇ   ‚îú‚îÄ‚îÄ Controllers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OrderController.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ OrderQueryController.cs
‚îÇ   ‚îú‚îÄ‚îÄ Middleware/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ExceptionHandlingMiddleware.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ LoggingMiddleware.cs
‚îÇ   ‚îî‚îÄ‚îÄ Extensions/
‚îÇ       ‚îú‚îÄ‚îÄ DependencyInjection.cs
‚îÇ       ‚îî‚îÄ‚îÄ ApiConfiguration.cs
‚îÇ
‚îú‚îÄ‚îÄ OrderService.Application/            # Application Layer
‚îÇ   ‚îú‚îÄ‚îÄ Commands/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CreateOrder/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CreateOrderCommand.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CreateOrderCommandHandler.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CreateOrderCommandValidator.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ MarkOrderAsPaid/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ MarkOrderAsPaidCommand.cs
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ MarkOrderAsPaidCommandHandler.cs
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ MarkOrderAsPaidCommandValidator.cs
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ Queries/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ GetOrderById/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ GetOrderByIdQuery.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ GetOrderByIdQueryHandler.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ GetAllOrders/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ GetAllOrdersQuery.cs
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ GetAllOrdersQueryHandler.cs
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ Events/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OrderPlacedEvent.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OrderPaidEvent.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ OrderCancelledEvent.cs
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ DTOs/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OrderDto.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OrderItemDto.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CreateOrderRequest.cs
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ Mappings/
‚îÇ       ‚îî‚îÄ‚îÄ OrderProfile.cs
‚îÇ
‚îú‚îÄ‚îÄ OrderService.Domain/                 # Domain Layer
‚îÇ   ‚îú‚îÄ‚îÄ Aggregates/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Order.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OrderItem.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ OrderStatus.cs
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ Events/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ IDomainEvent.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OrderCreatedEvent.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OrderItemAddedEvent.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ OrderPaidEvent.cs
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ ValueObjects/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Money.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Address.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Email.cs
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ Interfaces/
‚îÇ       ‚îú‚îÄ‚îÄ IOrderRepository.cs
‚îÇ       ‚îî‚îÄ‚îÄ IRepository.cs
‚îÇ
‚îú‚îÄ‚îÄ OrderService.Infrastructure/         # Infrastructure Layer
‚îÇ   ‚îú‚îÄ‚îÄ Persistence/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ WriteDbContext.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Configurations/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ OrderConfiguration.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Repositories/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ OrderRepository.cs
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ ReadModels/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OrderView.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OrderItemView.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ReadDbContext.cs
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ Projections/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ OrderProjection.cs
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ Messaging/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Consumers/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OrderPlacedConsumer.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ InventoryReservedConsumer.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Publishers/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ EventPublisher.cs
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ Caching/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ RedisCacheService.cs
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ External/
‚îÇ       ‚îú‚îÄ‚îÄ PaymentService.cs
‚îÇ       ‚îî‚îÄ‚îÄ InventoryService.cs
‚îÇ
‚îú‚îÄ‚îÄ OrderService.Sagas/                  # SAGA Orchestration
‚îÇ   ‚îú‚îÄ‚îÄ OrderProcessingSaga.cs
‚îÇ   ‚îú‚îÄ‚îÄ OrderProcessingSagaState.cs
‚îÇ   ‚îî‚îÄ‚îÄ SagaConfiguration.cs
‚îÇ
‚îî‚îÄ‚îÄ OrderService.Tests/                  # Tests
    ‚îú‚îÄ‚îÄ Unit/
    ‚îÇ   ‚îú‚îÄ‚îÄ Domain/
    ‚îÇ   ‚îú‚îÄ‚îÄ Application/
    ‚îÇ   ‚îî‚îÄ‚îÄ Infrastructure/
    ‚îÇ
    ‚îú‚îÄ‚îÄ Integration/
    ‚îÇ   ‚îî‚îÄ‚îÄ OrderIntegrationTests.cs
    ‚îÇ
    ‚îî‚îÄ‚îÄ E2E/
        ‚îî‚îÄ‚îÄ OrderWorkflowTests.cs
```

---

## üíª Implementaci√≥n

### 1. Setup B√°sico (Program.cs)

```csharp
using MediatR;
using MassTransit;
using Microsoft.EntityFrameworkCore;

var builder = WebApplication.CreateBuilder(args);

// Add services
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// Add MediatR
builder.Services.AddMediatR(cfg => cfg.RegisterServicesFromAssembly(typeof(Program).Assembly));

// Add DbContexts
builder.Services.AddDbContext<WriteDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("WriteDb")));

builder.Services.AddScoped<ReadDbContext>();

// Add Repositories
builder.Services.AddScoped<IOrderRepository, OrderRepository>();

// Add Caching
builder.Services.AddStackExchangeRedisCache(options =>
{
    options.Configuration = builder.Configuration.GetConnectionString("Redis");
});

// Add MassTransit (Messaging)
builder.Services.AddMassTransit(x =>
{
    x.AddSaga<OrderProcessingSaga>()
        .EntityFrameworkRepository(r =>
        {
            r.ExistingDbContext<WriteDbContext>();
            r.UseSqlServer();
        });
    
    x.AddConsumer<OrderPlacedConsumer>();
    x.AddConsumer<InventoryReservedConsumer>();
    
    x.UsingRabbitMq((context, cfg) =>
    {
        cfg.Host(builder.Configuration.GetConnectionString("RabbitMQ"));
        cfg.ConfigureEndpoints(context);
    });
});

// Add Logging
builder.Logging.ClearProviders();
builder.Logging.AddSerilog(new LoggerConfiguration()
    .WriteTo.Console()
    .WriteTo.Seq("http://localhost:5341")
    .CreateLogger());

var app = builder.Build();

// Configure pipeline
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();
app.UseMiddleware<ExceptionHandlingMiddleware>();
app.UseMiddleware<RequestLoggingMiddleware>();

// Map endpoints
app.MapPost("/api/orders", async (
    CreateOrderRequest request,
    IMediator mediator,
    CancellationToken ct) =>
{
    var command = new CreateOrderCommand
    {
        CustomerId = request.CustomerId,
        Items = request.Items,
        ShippingAddress = request.ShippingAddress
    };
    
    var result = await mediator.Send(command, ct);
    return Results.Ok(result);
})
.Produces<OrderDto>(StatusCodes.Status201Created)
.Produces(StatusCodes.Status400BadRequest);

app.MapGet("/api/orders/{id}", async (
    Guid id,
    IMediator mediator,
    CancellationToken ct) =>
{
    var query = new GetOrderByIdQuery { OrderId = id };
    var result = await mediator.Send(query, ct);
    return Results.Ok(result);
})
.Produces<OrderDto>()
.Produces(StatusCodes.Status404NotFound);

app.Run();
```

### 2. Domain Aggregate (Order.cs)

```csharp
public class Order : AggregateRoot
{
    public Guid Id { get; private set; }
    public Guid CustomerId { get; private set; }
    public decimal Total { get; private set; }
    public OrderStatus Status { get; private set; }
    public Address ShippingAddress { get; private set; }
    public DateTime CreatedAt { get; private set; }
    public DateTime? PaidAt { get; private set; }
    
    private readonly List<OrderItem> _items = new();
    public IReadOnlyCollection<OrderItem> Items => _items.AsReadOnly();
    
    private Order() { } // EF Core
    
    public static Order Create(Guid customerId, Address shippingAddress)
    {
        var order = new Order
        {
            Id = Guid.NewGuid(),
            CustomerId = customerId,
            ShippingAddress = shippingAddress,
            Status = OrderStatus.Draft,
            CreatedAt = DateTime.UtcNow
        };
        
        order.AddDomainEvent(new OrderCreatedEvent(order.Id, customerId));
        return order;
    }
    
    public void AddItem(ProductId productId, int quantity, decimal unitPrice)
    {
        if (Status != OrderStatus.Draft)
            throw new InvalidOperationException("Cannot modify order in current state");
        
        var item = new OrderItem(Id, productId, quantity, unitPrice);
        _items.Add(item);
        
        Total = _items.Sum(i => i.SubTotal);
        
        AddDomainEvent(new OrderItemAddedEvent(Id, productId, quantity, unitPrice));
    }
    
    public void MarkAsPaid(PaymentId paymentId)
    {
        if (Status != OrderStatus.Draft)
            throw new InvalidOperationException("Cannot pay order in current state");
        
        Status = OrderStatus.Paid;
        PaidAt = DateTime.UtcNow;
        
        AddDomainEvent(new OrderPaidEvent(Id, paymentId, Total));
    }
    
    public void MarkAsCompleted()
    {
        if (Status != OrderStatus.Paid)
            throw new InvalidOperationException("Cannot complete unpaid order");
        
        Status = OrderStatus.Completed;
        
        AddDomainEvent(new OrderCompletedEvent(Id));
    }
}
```

### 3. Command Handler

```csharp
public class CreateOrderCommand : IRequest<OrderDto>
{
    public Guid CustomerId { get; set; }
    public List<OrderItemDto> Items { get; set; }
    public Address ShippingAddress { get; set; }
}

public class CreateOrderCommandHandler : IRequestHandler<CreateOrderCommand, OrderDto>
{
    private readonly IOrderRepository _orderRepository;
    private readonly ILogger<CreateOrderCommandHandler> _logger;
    private readonly IPublishEndpoint _publishEndpoint;
    
    public CreateOrderCommandHandler(
        IOrderRepository orderRepository,
        ILogger<CreateOrderCommandHandler> logger,
        IPublishEndpoint publishEndpoint)
    {
        _orderRepository = orderRepository;
        _logger = logger;
        _publishEndpoint = publishEndpoint;
    }
    
    public async Task<OrderDto> Handle(CreateOrderCommand request, CancellationToken ct)
    {
        // 1. Create Aggregate
        var order = Order.Create(request.CustomerId, request.ShippingAddress);
        
        foreach (var item in request.Items)
        {
            order.AddItem(item.ProductId, item.Quantity, item.UnitPrice);
        }
        
        // 2. Persist Aggregate
        await _orderRepository.AddAsync(order, ct);
        await _orderRepository.SaveChangesAsync(ct);
        
        // 3. Publish Domain Events (para proyecciones)
        var events = order.DomainEvents;
        foreach (var @event in events)
        {
            await _publishEndpoint.Publish(@event, ct);
        }
        
        order.ClearDomainEvents();
        
        _logger.LogInformation("Order {OrderId} created for customer {CustomerId}", 
            order.Id, order.CustomerId);
        
        // 4. Return DTO
        return new OrderDto
        {
            Id = order.Id,
            CustomerId = order.CustomerId,
            Total = order.Total,
            Status = order.Status.ToString(),
            Items = order.Items.Select(i => new OrderItemDto
            {
                ProductId = i.ProductId,
                Quantity = i.Quantity,
                UnitPrice = i.UnitPrice
            }).ToList(),
            CreatedAt = order.CreatedAt
        };
    }
}
```

### 4. Query Handler (Read Model)

```csharp
public class GetOrderByIdQuery : IRequest<OrderDto>
{
    public Guid OrderId { get; set; }
}

public class GetOrderByIdQueryHandler : IRequestHandler<GetOrderByIdQuery, OrderDto>
{
    private readonly ReadDbContext _readDb;
    private readonly IMemoryCache _cache;
    
    public GetOrderByIdQueryHandler(ReadDbContext readDb, IMemoryCache cache)
    {
        _readDb = readDb;
        _cache = cache;
    }
    
    public async Task<OrderDto> Handle(GetOrderByIdQuery request, CancellationToken ct)
    {
        // 1. Try cache first
        var cacheKey = $"order:{request.OrderId}";
        if (_cache.TryGetValue<OrderDto>(cacheKey, out var cached))
        {
            return cached;
        }
        
        // 2. Query from Read DB (Dapper - optimized for reads)
        var sql = @"
            SELECT 
                o.Id,
                o.CustomerId,
                o.Total,
                o.Status,
                o.CreatedAt,
                o.PaidAt,
                oi.ProductId,
                oi.ProductName,
                oi.Quantity,
                oi.UnitPrice,
                oi.SubTotal
            FROM OrderView o
            LEFT JOIN OrderItemView oi ON o.Id = oi.OrderId
            WHERE o.Id = @OrderId
        ";
        
        var orderDict = new Dictionary<Guid, OrderDto>();
        
        await _readDb.Connection.QueryAsync<OrderDto, OrderItemDto, OrderDto>(
            sql,
            (order, item) =>
            {
                if (!orderDict.TryGetValue(order.Id, out var orderEntry))
                {
                    orderEntry = order;
                    orderEntry.Items = new List<OrderItemDto>();
                    orderDict.Add(order.Id, orderEntry);
                }
                
                if (item != null)
                {
                    orderEntry.Items.Add(item);
                }
                
                return orderEntry;
            },
            new { OrderId = request.OrderId },
            splitOn: "ProductId"
        );
        
        if (!orderDict.TryGetValue(request.OrderId, out var result))
        {
            throw new NotFoundException($"Order {request.OrderId} not found");
        }
        
        // 3. Cache for 5 minutes
        _cache.Set(cacheKey, result, TimeSpan.FromMinutes(5));
        
        return result;
    }
}
```

### 5. Projection Handler

```csharp
public class OrderProjection : IConsumer<OrderPlacedEvent>
{
    private readonly ReadDbContext _readDb;
    private readonly ILogger<OrderProjection> _logger;
    
    public OrderProjection(ReadDbContext readDb, ILogger<OrderProjection> logger)
    {
        _readDb = readDb;
        _logger = logger;
    }
    
    public async Task Consume(ConsumeContext<OrderPlacedEvent> context)
    {
        var @event = context.Message;
        
        // Update Read Model
        var orderView = new OrderView
        {
            Id = @event.OrderId,
            CustomerId = @event.CustomerId,
            Total = @event.Total,
            Status = "Draft",
            CreatedAt = @event.OccurredAt,
            ItemCount = @event.Items.Count,
            Discount = CalculateDiscount(@event.Items)
        };
        
        await _readDb.OrderViews.AddAsync(orderView);
        
        foreach (var item in @event.Items)
        {
            var itemView = new OrderItemView
            {
                OrderId = @event.OrderId,
                ProductId = item.ProductId,
                ProductName = item.ProductName,
                Quantity = item.Quantity,
                UnitPrice = item.UnitPrice,
                SubTotal = item.SubTotal,
                Category = item.Category  // Pre-joined
            };
            
            await _readDb.OrderItemViews.AddAsync(itemView);
        }
        
        await _readDb.SaveChangesAsync();
        
        _logger.LogInformation("Projection updated for order {OrderId}", @event.OrderId);
    }
}
```

---

## üîÑ Casos de Uso

### Caso 1: Crear Orden (Write)

```csharp
// Request
POST /api/orders
{
    "customerId": "123e4567-e89b-12d3-a456-426614174000",
    "items": [
        {
            "productId": "789e4567-e89b-12d3-a456-426614174001",
            "quantity": 2,
            "unitPrice": 99.99
        }
    ],
    "shippingAddress": {
        "street": "123 Main St",
        "city": "New York",
        "zipCode": "10001"
    }
}

// Flow:
// 1. API ‚Üí CreateOrderCommand
// 2. MediatR ‚Üí CreateOrderCommandHandler
// 3. Handler ‚Üí Order.Create() (Aggregate)
// 4. Handler ‚Üí Repository.Save()
// 5. Handler ‚Üí Publish Domain Events
// 6. Event Bus ‚Üí OrderProjection (Update Read Model)
// 7. API ‚Üí Return OrderDto
```

### Caso 2: Consultar Orden (Read)

```csharp
// Request
GET /api/orders/123e4567-e89b-12d3-a456-426614174000

// Flow:
// 1. API ‚Üí GetOrderByIdQuery
// 2. MediatR ‚Üí GetOrderByIdQueryHandler
// 3. Handler ‚Üí Check Cache
// 4. Handler ‚Üí Query Read DB (Dapper)
// 5. Handler ‚Üí Cache result
// 6. API ‚Üí Return OrderDto
```

### Caso 3: Procesar Orden Completa (SAGA)

```csharp
// Flow:
// 1. OrderPlacedEvent ‚Üí OrderProcessingSaga iniciada
// 2. Saga ‚Üí Publish ReserveInventoryCommand
// 3. Inventory Service ‚Üí Reserve inventory
// 4. Inventory Service ‚Üí Publish InventoryReservedEvent
// 5. Saga ‚Üí Publish ProcessPaymentCommand
// 6. Payment Service ‚Üí Charge customer
// 7. Payment Service ‚Üí Publish PaymentProcessedEvent
// 8. Saga ‚Üí Publish OrderCompletedEvent
// 9. Order Service ‚Üí Mark order as completed
```

---

## üèõÔ∏è Principios de Dise√±o: SOLID, DDD, Programaci√≥n Funcional

### SOLID Principles

**Todo el c√≥digo generado por SintroNet sigue estrictamente los principios SOLID:**

#### Single Responsibility Principle (SRP)

```csharp
// ‚úÖ BIEN: Cada clase tiene UNA responsabilidad
public class OrderRepository
{
    // Responsabilidad √öNICA: Persistencia de Orders
    public async Task<Order> GetByIdAsync(Guid id) { ... }
    public async Task SaveAsync(Order order) { ... }
}

public class OrderProjection
{
    // Responsabilidad √öNICA: Actualizar Read Models
    public async Task Handle(OrderPlacedEvent @event) { ... }
}

// ‚ùå MAL: Violaci√≥n SRP
public class OrderService
{
    // ‚ùå Persiste, proyecta, notifica, calcula todo en uno
    public async Task CreateOrder(...) 
    {
        await _db.Save(order);
        await UpdateProjection(order);
        await SendNotification(order);
        await CalculateMetrics(order);
    }
}
```

#### Open/Closed Principle (OCP)

```csharp
// ‚úÖ Extensible sin modificar c√≥digo existente
public interface IOrderValidator
{
    ValidationResult Validate(Order order);
}

// Nueva validaci√≥n sin tocar c√≥digo existente
public class VipCustomerValidator : IOrderValidator
{
    public ValidationResult Validate(Order order) { ... }
}

app.Entity<Order>()
    .Write(model => model
        .WithValidator<BasicOrderValidator>()
        .WithValidator<VipCustomerValidator>()  // ‚Üê Nuevo sin romper existente
    );
```

#### Liskov Substitution Principle (LSP)

```csharp
// ‚úÖ Cualquier implementaci√≥n de IRepository es intercambiable
public interface IRepository<T>
{
    Task<T> GetByIdAsync(Guid id);
}

// Todas estas implementaciones son intercambiables
public class SqlOrderRepository : IRepository<Order> { ... }
public class InMemoryOrderRepository : IRepository<Order> { ... }
public class CosmosOrderRepository : IRepository<Order> { ... }
```

#### Interface Segregation Principle (ISP)

```csharp
// ‚úÖ Interfaces peque√±as y espec√≠ficas
public interface IReadRepository<T>
{
    Task<T> GetByIdAsync(Guid id);
    Task<List<T>> ListAsync();
}

public interface IWriteRepository<T>
{
    Task SaveAsync(T entity);
    Task DeleteAsync(Guid id);
}

// ‚ùå MAL: Interface grande y monol√≠tica
public interface IRepository<T>  // ‚ùå Puede que no necesites Delete
{
    Task<T> GetByIdAsync(Guid id);
    Task<List<T>> ListAsync();
    Task SaveAsync(T entity);
    Task DeleteAsync(Guid id);
    Task UpdateAsync(T entity);
    Task<bool> ExistsAsync(Guid id);
}
```

#### Dependency Inversion Principle (DIP)

```csharp
// ‚úÖ Dependencias hacia abstracciones, no implementaciones
public class OrderCommandHandler
{
    private readonly IOrderRepository _repository;  // ‚Üê Abstracci√≥n
    
    public OrderCommandHandler(IOrderRepository repository)
    {
        _repository = repository;
    }
}

// ‚ùå MAL: Dependencia directa a implementaci√≥n
public class OrderCommandHandler
{
    private readonly SqlOrderRepository _repository;  // ‚ùå Acoplamiento
}
```

### Domain-Driven Design (DDD)

#### Ubicuous Language (Lenguaje ubicuo)

```csharp
// ‚úÖ Usa el lenguaje del negocio
public class Order : AggregateRoot
{
    public void MarkAsPaid() { ... }           // "Marcar como pagado"
    public void ShipTo(Address address) { ... } // "Enviar a"
}

// ‚ùå MAL: Usa lenguaje t√©cnico
public class Order
{
    public void UpdateStatusToPaid() { ... }  // ‚ùå Muy t√©cnico
    public void AssignDestination(Address a) { ... }  // ‚ùå Ambiguo
}
```

#### Aggregate Roots

```csharp
// ‚úÖ Order es el Aggregate Root
public class Order : AggregateRoot
{
    private readonly List<OrderItem> _items = new();
    
    // Solo Order puede modificar sus Items (encapsulaci√≥n)
    public void AddItem(ProductId productId, int quantity, decimal price)
    {
        // Validaci√≥n de invariantes
        if (Status != OrderStatus.Draft)
            throw new InvalidOperationException("Cannot modify completed order");
        
        _items.Add(new OrderItem(productId, quantity, price));
    }
}
```

#### Value Objects

```csharp
// ‚úÖ Value Objects inmutables
public record Money
{
    public decimal Amount { get; init; }
    public string Currency { get; init; }
    
    public Money(decimal amount, string currency)
    {
        if (amount < 0)
            throw new ArgumentException("Amount cannot be negative");
        if (string.IsNullOrWhiteSpace(currency))
            throw new ArgumentException("Currency is required");
        
        Amount = amount;
        Currency = currency;
    }
    
    // Inmutable: Operaciones crean nuevo valor
    public Money Add(Money other)
    {
        if (Currency != other.Currency)
            throw new InvalidOperationException("Cannot add different currencies");
        
        return new Money(Amount + other.Amount, Currency);
    }
}
```

#### Domain Events

```csharp
// ‚úÖ Eventos de dominio con significado de negocio
public record OrderPlacedEvent : IDomainEvent
{
    public Guid OrderId { get; init; }
    public Guid CustomerId { get; init; }
    public Money Total { get; init; }  // ‚Üê Value Object
    public DateTime OccuredAt { get; init; } = DateTime.UtcNow;
}
```

### Programaci√≥n Funcional

#### Funciones Puras

```csharp
// ‚úÖ Funci√≥n pura: Sin side effects, siempre mismo resultado
public static Money CalculateDiscount(Money total, decimal percentage)
{
    return new Money(total.Amount * percentage / 100, total.Currency);
}

// ‚ùå MAL: Impura, side effect
public static Money CalculateDiscount(Money total, decimal percentage)
{
    _logger.Info("Calculating discount");  // ‚ùå Side effect
    return new Money(total.Amount * percentage / 100, total.Currency);
}
```

#### Immutabilidad

```csharp
// ‚úÖ Records inmutables por defecto
public record OrderDto(
    Guid Id,
    Money Total,
    OrderStatus Status
);

// Modificaci√≥n crea nuevo objeto
var original = new OrderDto(Id, Total, OrderStatus.Draft);
var updated = original with { Status = OrderStatus.Paid };  // ‚Üê Nuevo objeto
```

#### Expresiones vs Sentencias

```csharp
// ‚úÖ Expresiones (funcional)
var total = items.Sum(i => i.Price * i.Quantity);

// ‚ùå MAL: Imperativo
decimal total = 0;
foreach (var item in items)
{
    total += item.Price * item.Quantity;
}

// ‚úÖ Chaining funcional
var orders = await _repository
    .Query(o => o.Status == OrderStatus.Paid)
    .Where(o => o.CreatedAt > DateTime.UtcNow.AddDays(-30))
    .Select(o => o.Total)
    .Sum();
```

### Guard Clauses (Cl√°usulas de Guarda)

#### Fail Fast Pattern

```csharp
// ‚úÖ Cl√°usulas de guarda al inicio
public void AddItem(ProductId productId, int quantity, decimal price)
{
    // Guard clauses primero
    if (productId == null)
        throw new ArgumentNullException(nameof(productId));
    
    if (quantity <= 0)
        throw new ArgumentException("Quantity must be positive", nameof(quantity));
    
    if (price < 0)
        throw new ArgumentException("Price cannot be negative", nameof(price));
    
    if (Status != OrderStatus.Draft)
        throw new InvalidOperationException("Cannot modify completed order");
    
    // Happy path despu√©s
    var item = new OrderItem(productId, quantity, price);
    _items.Add(item);
    Total = _items.Sum(i => i.SubTotal);
}

// ‚ùå MAL: Guard clauses mezcladas
public void AddItem(ProductId productId, int quantity, decimal price)
{
    var item = new OrderItem(productId, quantity, price);  // ‚ùå Podr√≠a fallar
    
    if (Status != OrderStatus.Draft)  // ‚ùå Demasiado tarde
        throw new InvalidOperationException("Cannot modify completed order");
    
    _items.Add(item);
}
```

#### Result Pattern (Funcional)

```csharp
// ‚úÖ Result pattern para manejo funcional de errores
public record Result<T>
{
    public bool IsSuccess { get; init; }
    public T Value { get; init; }
    public string Error { get; init; }
    
    public static Result<T> Success(T value) => new() { IsSuccess = true, Value = value };
    public static Result<T> Failure(string error) => new() { IsSuccess = false, Error = error };
}

public Result<Order> AddItem(ProductId productId, int quantity, decimal price)
{
    // Guard clauses retornan Result
    if (productId == null)
        return Result<Order>.Failure("Product ID is required");
    
    if (quantity <= 0)
        return Result<Order>.Failure("Quantity must be positive");
    
    // Happy path
    var item = new OrderItem(productId, quantity, price);
    _items.Add(item);
    
    return Result<Order>.Success(this);
}

// Uso con chaining funcional
var result = order
    .AddItem(productId, quantity, price)
    .Map(o => o.CalculateTotal())
    .Map(o => o.ApplyDiscount(discountCode));
```

### Combinando Todo

```csharp
// ‚úÖ Ejemplo completo aplicando todos los principios
public class Order : AggregateRoot
{
    private readonly List<OrderItem> _items = new();
    
    // DDD: Ubicuous Language
    // Guard Clauses: Fail fast
    // Inmutabilidad: Muta solo internamente
    public Result<Order> AddItem(ProductId productId, int quantity, Money price)
    {
        // Guard clauses
        if (productId == null)
            return Result<Order>.Failure("Product ID is required");
        
        if (quantity <= 0)
            return Result<Order>.Failure("Quantity must be positive");
        
        if (price.Amount < 0)
            return Result<Order>.Failure("Price cannot be negative");
        
        if (Status != OrderStatus.Draft)
            return Result<Order>.Failure("Cannot modify completed order");
        
        // Domain logic (pure)
        var item = new OrderItem(productId, quantity, price);
        _items.Add(item);
        
        // Immutability: crear nuevo evento en lugar de mutar
        AddDomainEvent(new OrderItemAddedEvent(Id, productId, quantity));
        
        return Result<Order>.Success(this);
    }
    
    // Funcional: m√©todo puro sin side effects
    private Money CalculateTotal() =>
        _items.Aggregate(
            new Money(0, "USD"),
            (sum, item) => sum.Add(item.SubTotal)
        );
}
```

---

## üß™ Estrategia de Testing

### Filosof√≠a: Testing como Superpoder

**SintroNet** sigue la filosof√≠a de **SyntroJS**: "Testing no es una molestia, es un superpoder que te da confianza para refactorizar agresivamente."

### Pir√°mide de Testing

```
        ‚ï±‚ï≤
       ‚ï±E2E‚ï≤
      ‚ï±‚îÄ‚îÄ‚îÄ‚îÄ‚ï≤
     ‚ï±      ‚ï≤
    ‚ï±Integration‚ï≤
   ‚ï±‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ï≤
  ‚ï±              ‚ï≤
 ‚ï±    Unit        ‚ï≤
‚ï±‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ï≤
```

**Ratio recomendado:**
- **80% Unit Tests** - R√°pidos, aislados, feedback inmediato
- **15% Integration Tests** - Validar interacciones
- **5% E2E Tests** - Validar flujos cr√≠ticos

---

### 1. Testing de Agregados (Unitario)

#### Objetivo
Testear la **l√≥gica de negocio pura** y la **emisi√≥n de eventos de dominio** sin dependencias externas.

#### Principios
- ‚úÖ Sin mocks
- ‚úÖ Sin bases de datos
- ‚úÖ Sin frameworks pesados
- ‚úÖ Test de 100ms o menos

#### Ejemplo

```csharp
[Fact]
public void AddItem_Should_EmitOrderItemAddedEvent()
{
    // Arrange
    var order = Order.Create(customerId, shippingAddress);
    
    // Act
    order.AddItem(productId, 2, 99.99m);
    
    // Assert
    var events = order.DomainEvents;
    events.Should().ContainSingle(e => 
        e is OrderItemAddedEvent added && 
        added.Quantity == 2 &&
        added.UnitPrice == 99.99m
    );
}

[Fact]
public void AddItem_When_OrderIsPaid_Should_Throw()
{
    // Arrange
    var order = Order.Create(customerId, shippingAddress);
    order.MarkAsPaid(paymentId);
    
    // Act & Assert
    Assert.Throws<InvalidOperationException>(() => 
        order.AddItem(productId, 1, 50m)
    );
}

[Fact]
public void CalculateTotal_Should_SumAllItems()
{
    // Arrange
    var order = Order.Create(customerId, shippingAddress);
    order.AddItem(product1, 2, 50m);  // 100
    order.AddItem(product2, 1, 75m);  // 75
    
    // Act
    var total = order.CalculateTotal();
    
    // Assert
    total.Amount.Should().Be(175m);
}
```

**Beneficios:**
- ‚ö° Tests ultra-r√°pidos (< 10ms)
- üéØ Enfoque en l√≥gica de negocio
- üîí Valida invariantes del dominio
- üßπ Sin infraestructura

---

### 2. Testing de Command Handlers (Integraci√≥n)

#### Objetivo
Validar la **orquestaci√≥n** entre handler, repositorio y bus de eventos.

#### Estrategia
- ‚úÖ Repositorio en memoria
- ‚úÖ Bus de eventos mockeado
- ‚úÖ Base de datos en memoria (SQLite)

#### Ejemplo

```csharp
public class CreateOrderCommandHandlerTests : IDisposable
{
    private readonly DbContext _dbContext;
    private readonly Mock<IPublishEndpoint> _publishEndpoint;
    private readonly CreateOrderCommandHandler _handler;
    
    public CreateOrderCommandHandlerTests()
    {
        _dbContext = new WriteDbContext(/* SQLite in-memory */);
        _publishEndpoint = new Mock<IPublishEndpoint>();
        _handler = new CreateOrderCommandHandler(
            new OrderRepository(_dbContext),
            _publishEndpoint.Object
        );
    }
    
    [Fact]
    public async Task Handle_Should_SaveOrderAndPublishEvent()
    {
        // Arrange
        var command = new CreateOrderCommand
        {
            CustomerId = customerId,
            Items = new[] { new OrderItemDto(productId, 2, 50m) }
        };
        
        // Act
        var result = await _handler.Handle(command, CancellationToken.None);
        
        // Assert - Order persisted
        var order = await _dbContext.Orders.FindAsync(result.Id);
        order.Should().NotBeNull();
        order.Items.Should().HaveCount(1);
        
        // Assert - Event published
        _publishEndpoint.Verify(p => 
            p.Publish(It.Is<OrderPlacedEvent>(
                e => e.OrderId == result.Id
            ), It.IsAny<CancellationToken>()),
            Times.Once
        );
    }
}
```

**Beneficios:**
- ‚úÖ Valida SRP (handler solo orquesta)
- ‚úÖ Integra repositorio y eventos
- ‚úÖ R√°pido (< 500ms)

---

### 3. Testing de Proyecciones (Integraci√≥n)

#### Objetivo
Validar que los eventos actualizan correctamente el read model.

#### Estrategia
- ‚úÖ Event bus en memoria
- ‚úÖ Read database en memoria
- ‚úÖ Verificar estado final

#### Ejemplo

```csharp
[Fact]
public async Task OrderPlacedEvent_Should_UpdateOrderView()
{
    // Arrange
    var @event = new OrderPlacedEvent
    {
        OrderId = Guid.NewGuid(),
        CustomerId = Guid.NewGuid(),
        Total = 150m,
        Items = new[] { new OrderItemDto(productId, 2, 50m) }
    };
    
    var projection = new OrderProjection(readDbContext);
    
    // Act
    await projection.Handle(@event, CancellationToken.None);
    
    // Assert
    var view = await readDbContext.OrderViews.FindAsync(@event.OrderId);
    view.Should().NotBeNull();
    view.Total.Should().Be(150m);
    view.ItemCount.Should().Be(1);
    view.Status.Should().Be("Draft");
}
```

**Beneficios:**
- ‚úÖ Valida consistencia eventual
- ‚úÖ Verifica denormalizaci√≥n
- ‚úÖ Asegura proyecciones correctas

---

### 4. Testing de Queries (Integraci√≥n)

#### Objetivo
Validar que los read models se consultan correctamente.

#### Estrategia
- ‚úÖ Pre-popular base de datos
- ‚úÖ Ejecutar query handler
- ‚úÖ Verificar DTO resultante

#### Ejemplo

```csharp
[Fact]
public async Task GetOrderById_Should_ReturnCachedOrder()
{
    // Arrange - Pre-populate
    var orderView = new OrderView
    {
        Id = orderId,
        CustomerId = customerId,
        Total = 200m,
        Status = "Paid"
    };
    await readDbContext.OrderViews.AddAsync(orderView);
    await readDbContext.SaveChangesAsync();
    
    var handler = new GetOrderByIdQueryHandler(readDbContext, cache);
    
    // Act
    var result = await handler.Handle(
        new GetOrderByIdQuery { OrderId = orderId },
        CancellationToken.None
    );
    
    // Assert
    result.Id.Should().Be(orderId);
    result.Total.Should().Be(200m);
    result.Status.Should().Be("Paid");
}
```

**Beneficios:**
- ‚úÖ Valida separaci√≥n CQRS
- ‚úÖ Verifica optimizaciones (Dapper)
- ‚úÖ Asegura caching

---

### 5. Testing de Sagas (End-to-End)

#### Objetivo
Validar el flujo completo de una transacci√≥n distribuida.

#### Estrategia
- ‚úÖ MassTransit Test Framework
- ‚úÖ Saga en memoria
- ‚úÖ Validar transiciones de estado

#### Ejemplo

```csharp
public class OrderProcessingSagaTests : InMemoryTestFixture
{
    [Fact]
    public async Task OrderFlow_Should_Complete_Successfully()
    {
        // Arrange
        var saga = new OrderProcessingSaga();
        var sagaRepository = new InMemorySagaRepository<OrderProcessingState>();
        
        // Act - Initiate saga
        await saga.Initialize(
            new OrderPlacedEvent { OrderId = orderId },
            sagaRepository
        );
        
        // Assert - Step 1: Inventory should be reserved
        var state = await sagaRepository.Get(orderId);
        state.CurrentState.Should().Be("ReservingInventory");
        
        // Act - Simulate inventory reserved
        await saga.Handle(
            new InventoryReservedEvent { OrderId = orderId }
        );
        
        // Assert - Step 2: Payment should be processed
        state = await sagaRepository.Get(orderId);
        state.CurrentState.Should().Be("ProcessingPayment");
        
        // Act - Simulate payment processed
        await saga.Handle(
            new PaymentProcessedEvent { OrderId = orderId }
        );
        
        // Assert - Final: Order completed
        state = await sagaRepository.Get(orderId);
        state.CurrentState.Should().Be("Completed");
    }
    
    [Fact]
    public async Task PaymentFails_Should_Compensate()
    {
        // Arrange
        var saga = InitializeSaga();
        
        // Act - Payment fails
        await saga.Handle(
            new PaymentFailedEvent { OrderId = orderId }
        );
        
        // Assert - Compensate
        var state = await sagaRepository.Get(orderId);
        state.CurrentState.Should().Be("Compensating");
        
        // Assert - Inventory released
        busMock.Verify(b => b.Publish(
            It.Is<ReleaseInventoryCommand>(c => c.OrderId == orderId),
            It.IsAny<CancellationToken>()
        ), Times.Once);
    }
}
```

**Beneficios:**
- ‚úÖ Valida flujo completo
- ‚úÖ Asegura compensaciones
- ‚úÖ Behavior emergente verificado

---

### 6. Mutation Testing con Stryker

#### ¬øPor qu√© Mutation Testing?

**Problema:** Coverage del 80% no garantiza tests √∫tiles.

```csharp
// Test con cobertura alta, pero in√∫til
[Fact]
public void CalculateTotal_Should_ReturnSomething()
{
    var total = order.CalculateTotal();
    Assert.NotNull(total);  // ‚ùå No valida nada √∫til
}
```

**Soluci√≥n:** Stryker introduce "mutantes" (bugs artificiales) y verifica que tus tests los matan.

#### Configuraci√≥n

```xml
<ItemGroup>
  <PackageReference Include="Stryker.NET" Version="1.17.0" />
</ItemGroup>
```

```json
// stryker-config.json
{
  "mutate": [
    "src/**/*.cs"
  ],
  "test-projects": [
    "tests/**/*.csproj"
  ],
  "thresholds": {
    "high": 80,
    "break": 70
  }
}
```

#### Ejecutar

```bash
dotnet stryker
```

**Output:**
```
All mutants have been tested, and your mutation score has been calculated
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      Mutation Score                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Killed   ‚îÇ 157 (82.2%)                                        ‚îÇ
‚îÇ Survived ‚îÇ 34 (17.8%)                                         ‚îÇ
‚îÇ Timeout  ‚îÇ 0 (0%)                                             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Total    ‚îÇ 191 mutations                                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

#### Mutantes Comunes

```csharp
// Original
if (quantity > 0) { ... }

// Mutante 1: Condici√≥n inversada
if (quantity <= 0) { ... }  // ‚ùå ¬øTu test falla? ¬°Perfecto!

// Mutante 2: Operador cambiado
if (quantity < 0) { ... }   // ‚ùå ¬øTu test falla? ¬°Perfecto!

// Mutante 3: Eliminar condici√≥n
{ ... }                     // ‚ùå ¬øTu test falla? ¬°Perfecto!
```

#### Integraci√≥n Continua

```yaml
# .github/workflows/mutation-testing.yml
name: Mutation Testing

on: [pull_request]

jobs:
  mutation:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Setup .NET
        uses: actions/setup-dotnet@v1
        with:
          dotnet-version: '8.0'
      
      - name: Run Stryker
        run: dotnet stryker
      
      - name: Upload Report
        uses: actions/upload-artifact@v2
        with:
          name: mutation-report
          path: MutationReport.html
```

---

### M√©tricas de Testing

| M√©trica | Objetivo | Herramienta |
|---------|----------|-------------|
| **Coverage** | > 80% | Coverlet |
| **Mutation Score** | > 75% | Stryker |
| **Test Speed** | < 30s (unitarios) | xUnit |
| **Failing Tests** | 0 | CI/CD |

---

## ü§ñ Consideraciones para Agentes de IA

### Patrones Clave a Entender

1. **Siempre separar Write y Read**
   - Write: Use Aggregates (EF Core)
   - Read: Use DTOs (Dapper)

2. **Los eventos son el pegamento**
   - Todo cambio de estado genera un evento
   - Los eventos actualizan proyecciones autom√°ticamente

3. **SAGA maneja transacciones distribuidas**
   - No uses transacciones ACID distribuidas
   - Usa compensaciones (rollback manual)

4. **Optimiza Reads agresivamente**
   - Pre-c√°lculo
   - Denormalizaci√≥n
   - Caching

5. **Sigue SOLID, DDD, y Programaci√≥n Funcional**
   - Single Responsibility: Una clase, una raz√≥n para cambiar
   - Domain-Driven: Lenguaje ubicuo, agregados, value objects
   - Funcional: Funciones puras, inmutabilidad, guard clauses

### C√≥digo de Ejemplo Generado

Todos los ejemplos de c√≥digo en esta gu√≠a siguen estrictamente:
- ‚úÖ SOLID Principles
- ‚úÖ Domain-Driven Design (DDD)
- ‚úÖ Programaci√≥n Funcional
- ‚úÖ Guard Clauses (Fail Fast)

Cada handler, aggregate, y servicio implementa estos principios para garantizar c√≥digo mantenible, testeable y escalable.

### Comandos √ötiles

```bash
# Crear migraci√≥n (Write DB)
dotnet ef migrations add AddOrderStatus --project OrderService.Infrastructure --startup-project OrderService.Api

# Aplicar migraci√≥n
dotnet ef database update --project OrderService.Infrastructure --startup-project OrderService.Api

# Ejecutar tests
dotnet test --verbosity normal

# Observar logs en Seq
# Ir a http://localhost:5341
```

### Red Flags a Evitar

‚ùå **Mezclar Write y Read en el mismo handler**
```csharp
// MAL
public async Task<OrderDto> Handle(CreateOrderCommand request)
{
    var order = Order.Create(...);
    await SaveOrder(order);
    
    // MAL: Leer de la misma DB donde acabas de escribir
    var savedOrder = await ReadOrder(order.Id);
    return savedOrder;
}
```

‚ùå **Usar EF Core para Reads**
```csharp
// MAL: Muy lento
var orders = await _context.Orders
    .Include(o => o.Items)
    .Include(o => o.Customer)
    .Where(o => o.Status == "Paid")
    .ToListAsync();
```

‚ùå **Transacciones distribuidas ACID**
```csharp
// MAL: No funciona en microservicios
using var transaction = scope.BeginTransaction();
await ReserveInventory();
await ChargePayment();
transaction.Commit();
```

‚úÖ **En lugar de eso:**
- Usa Dapper para reads
- Usa SAGA para transacciones distribuidas
- Usa proyecciones para mantener consistencia eventual

---

## üìä M√©tricas de √âxito

- **Write Latency**: < 50ms (p95)
- **Read Latency**: < 10ms (p95)
- **Throughput**: > 10,000 req/s (reads)
- **Consistency Window**: < 1 segundo (eventual)
- **Availability**: 99.9%

---

## üîó Recursos Adicionales

- [Martin Fowler - CQRS](https://martinfowler.com/bliki/CQRS.html)
- [MassTransit Documentation](https://masstransit.io/)
- [MediatR Library](https://github.com/jbogard/MediatR)
- [EF Core Best Practices](https://learn.microsoft.com/en-us/ef/core/performance/)

---

**Filosof√≠a Final:** "Separa para dominar. Optimiza reads y writes por separado. Usa eventos para la consistencia eventual. Los SAGAs manejan las transacciones distribuidas. El rendimiento viene de la arquitectura, no del hardware."
